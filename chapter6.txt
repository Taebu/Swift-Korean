# 06 컬렉션 타입 Collection Types #

스위프트는 여러 값들을 한꺼번에 저장하기 위해 배열과 딕셔너리로 알려진 두가지 *컬렉션 타입*을 제공한다. 배열은 동일한 타입을 가진 값을 순서대로 저장한다. 딕셔너리는 동일한 타입을 가진 값을 순서와 상관 없이 저장한다. 따라서, 딕셔너리는 유일한 식별자인 키를 통해 값을 찾고 참조하게 된다.

스위프트에서 배열과 딕셔너리는 항상 자신이 저장하고자 하는 키와 값의 타입을 확인한다. 이것은 다른 타입을 가진 값을 배열이나 딕셔너리에 실수로라도 저장하지 못한다는 것을 의미한다. 이는 또한 배열과 딕셔너리에서 값을 가져올 때 어떤 타입의 값을 가져올 수 있는지 확신할 수 있다는 의미이기도 하다. 스위프트에서 이렇게 명시적인 타입 컬렉션을 사용하는 것은 당신의 코드가 명확한 밸류 타입을 가져야 하게끔 하는 것이며 개발시 타입이 맞는지 아닌지를 바로바로 잡아낼 수 있게끔 해준다는 것이다.

> **참고:**
> 스위프트의 `Array` 타입은 상수나 변수에 지정될 때, 혹은 함수나 메소드에서 사용될 때 다른 타입들과 다른 행동을 보여준다. 더 자세한 내용은 "컬렉션의 값 변형"\*링크필요\* 섹션과 "컬렉션 타입에서 할당과 복사 형태"\*링크필요\* 섹션을 참고하도록 하자.


## 배열 Arrays ##

배열은 같은 타입을 가진 여러개의 값을 순서대로 저장한다. 한 배열 안에서는 같은 값이 여러 다른 위치에서 나타날 수 있다.

스위프트에서 배열은 특정한 종류들의 값들을 저장할 수 있다. 이것은 Objective-C의 `NSArray`와 `NSMutableArray` 클라스와는 다르다. `NSArray`와 `NSMutableArray` 클라스는 어느 종류의 객체든 저장할 수 있고, 반환하는 객체의 속성에 대한 어떠한 정보도 제공하지 않는다. 반면에 스위프트에서는 특정 배열에 저장할 수 있는 밸류 타입은 항상 명시적인 타입 선언을 통하거나 타입 추정을 통해 확인한다. 굳이 클라스 타입이 될 필요는 없다. 예를 들어 만약 당신이 `Int` 타입 배열을 하나 생성한다고 하면, `Int` 값이 아닌 어떤 값도 이 배열에 대입할 수 없다. 스위프트는 타입 지정에 대해 안전하고, 배열 안에 무슨 타입이 들어있는지를 혹은 들어갈지를 항상 확인한다.


## 배열 타입 축약 문법 Array Type Shorthand Syntax ##

스위프트 배열 타입을 정확하게 쓰려면 `Array<SomeType>` 형태로 해야 한다. 여기서 `SomeType`은 배열에 저장할 타입을 의미한다. 또한 축약 형태인 `SomeType[]`으로도 배열을 사용할 수 있다. 이 두 가지 형태가 기능적으로는 동일할지라도, 축약 형태를 사용하는 것을 권장한다. 이 축약 형태의 배열이 이 가이드 문서에서도 계속 쓰일 것이다.


## 배열 표현식 Array Literals ##

배열은 배열 표현식을 통해서 초기화를 시킬 수 있다. 배열 표현식은 하나 또는 그 이상의 값들을 배열 컬렉션에 담는 축약 형태를 가리킨다. 배열 표현식은 대괄호로 둘러싸고, 콤마로 값들을 구분하는 형태로 하여 여러개의 값들을 표현한다.

```
[value1, value2, value3]
```

아래는 `String` 타입의 값들을 저장하는 `shoppingList`라는 배열을 생성하는 예제이다.

```
var shoppingList: String[] = ["Eggs", "Mink"]

// shoppingList has been initialized with two initial items
```

`shoppingList` 변수는 "`String` 타입의 값들을 갖는 배열"로 정의했기 때문에 `String[]` 타입으로 배열 타입을 지정했다. 이렇게 `Strign` 타입을 갖는 것으로 배열 타입을 지정했기 때문에 이 배열은 오직 `String` 값들만을 저장할 수 있다. 여기서 `shoppingList` 배열은 두 "`Eggs`", "`Mink`" `String` 값을 배열 표현식으로 지정하여 초기화를 시켰다.

> **참고:**
> 이 `shoppingList` 배열은 다음에 나올 예제에서 더 많은 쇼핑 목록을 추가하기 때문에 상수를 위한 `let` introducer가 아닌 `var` introducer를 통해 변수로 지정했다.

이 경우에 배열 표현식은 두 `String` 값 이외에는 다른 것을 포함하지 않는다. 이것은 `shoppingList` 변수의 타입 정의 &ndash; 오직 `String` 타입의 값들만 저장할 수 있는 배열 &ndash; 와 일치한다. 따라서, 배열 표현식을 이용하여 `shoppingList` 변수를 초기화 하는 것이 허용된다.

스위프트의 타입 추정 덕분에 당신은 배열 표현식을 이용하여 같은 타입을 갖는 변수를 초기화 시킨다면 배열 타입을 쓸 필요가 없다. 따라서, `shoppingList` 변수의 초기화는 아래와 같이 좀 더 간결한 형태로도 가능하다.

```
var shoppingList = ["Eggs", "Mink"]
```

배열 표현식의 모든 값들이 모두 같은 타입이기 때문에 스위프트는 `String[]`이 `shoppingList` 변수의 사용에 맞는 타입이라고 추정할 수 있다.


## 배열의 접근 및 수정 Accessing and Modifying an Array ##

배열은 메소드와 프로퍼티를 통해 접근과 수정이 가능하다. 혹은 subscript 문법을 사용할 수도 있다.

To find out the number of items in an array, check its read-only count property:

배열 안에 값이 몇 개나 있는지를 확인하기 위해 일기 전용 속성인 `count` 프로퍼티를 사용한다:

```
println("The shopping list contains \(shoppingList.count) items.")

// prints "The shopping list contains 2 items."
```

불리언 값을 반환하는 `isEmpty` 프로퍼티를 이용하면 `count` 프로퍼티 값이 `0`인지 아닌지 곧바로 확인할 수 있다:

```
if shoppingList.isEmpty {
    println("The shopping list is empty.")
} else {
    println("The shopping list is not empty.")
}

// prints "The shopping list is not empty."
```

새로운 값을 배열의 마지막에 추가하는 것은 `append` 메소드를 이용하면 된다:

```
shoppingList.append("Flour")

// shoppingList now contains 3 items, and someone is making pancakes
```

추가 할당 연산자인 `+=`를 이용하여 배열의 마지막에 새로운 값을 추가할 수도 있다.

```
shoppingList += "Baking Powder"

// shoppingList now contains 4 items
```

같은 타입을 갖는 배열 표현식을 이용하여 한꺼번에 추가시킬 수도 있다:

```
shoppingList += ["Chocolate Spread", "Cheese", "Butter"]

// shoppingList now contains 7 items
```

배열로부터 값을 찾는 것은 배열 변수 바로 뒤에 대괄호를 사용해서 찾고자 하는 값의 인덱스값을 이용하면 된다:

```
var firstItem = shoppingList[0]

// firstItem is equal to "Eggs"
```

배열의 첫번째 값이 갖는 인덱스는 `0`이다. `1`이 아님을 명심하자. 스위프트에서 배열의 인덱스는 항상 0부터 시작한다.

Subscript 문법을 사용하면 지정한 인덱스에 이미 존재하는 값을 바꿀 수도 있다:

```
shoppingList[0] = "Six eggs"

// the first item in the list is now equal to "Six eggs" rather than "Eggs"
```

Subscript 문법을 이용하면 범위를 줘서 한꺼번에 값을 바꿀 수도 있다. 심지어는 바꾸려고 하는 범위가 실제 값의 크기와 달라도 그게 가능하다. 아래 예제는 `shoppingList` 배열에 있는 "`Chocolate Spread`", "`Cheese`", "`Butter`" 값을 "`Bananas`", "`Apples`"으로 바꾸어 버린다:

```
shoppingList[4...6] = ["Bananas", "Apples"]

// shoppingList now contains 6 items
```

N O T E
You can’t use subscript syntax to append a new item to the end of an array. If you try to use subscript
syntax to retrieve or set a value for an index that is outside of an array’s existing bounds, you will trigger a
runtime error. However, you can check that an index is valid before using it, by comparing it to the array’s
count property. Except when count is 0 (meaning the array is empty), the largest valid index in an array will
always be count - 1, because arrays are indexed from zero.

> **참고:**
> Subscript 문법을 사용해서 새 값을 배열의 마지막에 추가하는 것은 안된다. 만약에 배열의 크기보다 큰 인덱스 값을 사용해서 배열에 접근하려 한다면 런타임 에러를 확인할 수 있을 것이다. 하지만 유효한 인덱스 값은 사용 전에 배열의 `count` 프로퍼티를 이용하여 확인이 가능하다. `count` 프로퍼티 값이 `0`인 경우 &ndash; 빈 배열인 경우 &ndash; 를 제외하면 배열에서 가장 큰 인덱스 값은 항상 `count - 1`이 될 것이다. 인덱스는 항상 `0`에서 시작하기 때문이다.

특정한 인덱스에 배열 값을 넣고 싶다면 배열의 `insert(atIndex:)` 메소드를 이용한다:

```
shoppingList.insert("Maple Syrup", atIndex: 0)

// shoppingList now contains 7 items
// "Maple Syrup" is now the first item in the list
```

이것은 `insert` 메소드를 이용하여 "`Mayple Syrup`"이란 새로운 값을 `shoppingList` 배열의 가장 앞 &ndash; `0` 인덱스 값을 가진 곳 &ndash; 에 넣는 것이다.

비슷한 방식으로 배열에서 값을 지울 수도 있다. `removeAtIndex` 메소드를 이용하면 되는데, 이 메소드는 배열내 주어진 인덱스에서 특정 값을 지우고 난 후 그 지워진 값을 반환한다. 이 지워진 값은 필요하지 않다면 무시해도 좋다.

```
let mapleSyrup = shoppingList.removeAtIndex(0)

// the item that was at index 0 has just been removed
// shoppingList now contains 6 items, and no Maple Syrup
// the mapleSyrup constant is now equal to the removed "Maple Syrup" string
```

배열에서 값을 지우고난 다음에 생기는 공백은 자동으로 지워진다. 따라서, `0` 인덱스에 해당하는 값은 이제 "`Six eggs`"이다:

```
firstItem = shoppingList[0]

// firstItem is now equal to "Six eggs"
```

만약 배열의 마지막 값을 지우고 싶다면 `removeLast` 메소드를 이용한다. 이 메소드를 이용하면 `removeAtIndex` 메소드를 `count` 프로퍼티와 함께 사용하는 불필요한 수고를 피할 수 있다. `removeAtIndex` 메소드와 마찬가지로 `removeLast` 메소드 역시 지워진 값을 반환한다:

```
let apples = shoppingList.removeLast()

// the last item in the array has just been removed
// shoppingList now contains 5 items, and no cheese
// the apples constant is now equal to the removed "Apples" string
```

