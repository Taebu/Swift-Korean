# 07 흐름 제어  (Control Flow)
> Translator : 김나솔(nasol.kim@gmail.com)

Swift 언어에서는 C언어 같은 프로그래밍 언어에서 제공하는 것과 비슷한 제어문 관련 constructs를 제공합니다. 이러한 constructs에는 `for`나 `while`이 있으며, 이러한 키워드는 어떤 과제(task)를 여러 번 수행합니다. `if`와 `switch`문은 특정 조건이 충족되는지에 따라서 분기시켜서 코드 블럭을 실행시킵니다. 또한 `break`나 `continue` 같은 구문은 실행의 흐름을 코드 상의 다른 곳으로 이동시킵니다.

C언어에서는 `for`-조건부-증가(increment) 순환문(loop) 이런 방식을 전통적으로 사용하는데, Swfit에서는 `for-in` 순환문(loop)이라는 것이 있어서 배열이나 사전(dictionaries), ranges, 문자열(strings)등 sequence에 대해서iteration하기가 쉽습니다. 
 
C언어의 `switch`문과 비교했을 때, Swift의 `switch`문은 훨씬 더 강력합니다. Swift에서는 `switch`문이 "fall through" 하지 않습니다(역자주: fall through란, switch문에서 한 case에 대해서 처리하고 난 후 다음 case로 넘어가는 것). C언어에서는 실수로 `break`문을 써주지 않아서 에러가 생기는 경우가 있는데 Swift에서는 fall through 하지 않기 때문에 이런 에러를 방지할 수 있습니다. `swich`내의 case에 대해서 여러 종류의 pattern-maching을 사용할 수 있습니다. 수의 범위 match, 투플 match, casts to a specific type. `switch case`에서 match된 값을 임시 상수나 변수에 binding할 수도 있습니다. 이렇게 binding해두면 case의 본문(body) 내에서 이 상수나 변수를 사용할 수 있습니다. 또한 매칭 조건(matching condition)이 복잡한 경우에는, 각 case에 대해서 where절(where clause)을 사용해서 표현할 수 있습니다.  

## `For` 순환문(For Loops)

`for` 순환문(for loop) 사용하면 코드 블럭을 특정 횟수 만큼 수행할 수 있습니다. Swift에는 두 종류의 for 순환문이 있습니다:

* `for-in` : 어떤 범위나 sequence, collection, progression에 대해서, 이 안에 있는 각 항목(item)에 대해서 코드(a set of statement)를 실행합니다. 

* `for-condition-increment` : 특정 조건부가 참이 될 때까지 코드를 실행합니다. 보통 루프를 한 번 도는 것이 끝날 때마다 counter를 1씩 증가시킵니다.  

 ## `For-In`
 
여러 항목이 들어 있는 컬렉션(collection)이나, 어떤 범위, 배열 안에 들어 있는 항목(item)에 대해서, 또는 문자열에 들어 있는 각 문자에 대해서 iteration을 할 때 `for-in` loop를 사용합니다. 

다음의 예는 구구단의 5단에서 처음 몇 개를 출력해 줍니다: 
```
for index in  1...5 {       println("\(index) times 5 is \(index * 5)") 
 } 
// 1 times 5 is 5   
// 2 times 5 is  10   
// 3 times 5 is  15   
// 4 times 5 is 20   
// 5 times 5 is 25  
```

위 예에서는 범위가 1부터 5까지로 정해져 있고(closed range of numbers),  이 범위에 대해서 컬렉션(collection)안에 들어 있는 각 항목(item)에 대해 이터레이션을 돌고 있습니다. 단, 1...5라고 표현했을 때, ...(closed range operator)를 보면 알 수 있듯이, 이 범위에는 1과 5가 포함됩니다. 인덱스(index)의 값은 범위 내의 첫번째 수, 즉 1이 되며, 루프 내에 있는 구문이 실행됩니다. 위 예에서 루프 안에는 구문이 하나만 있습니다. 인덱스의 현재 값에 대해서 5단의 첫번째를 출력해주는 것입니다. 이 구문이 실행된 다음에 인덱스의 값은 범위 내의 두번째 값, 즉 2가 되도록 업데이트 됩니다. 그리고 printLn 함수가 다시 호출됩니다. 이 작업은 인덱스가 범위의 끝에 이를 때까지 계속됩니다.  

위 예에서 인덱스는 상수(constant)이며, 이 상수의 값은 루프를 돌 때마다, 초반에 자동으로 값이 지정됩니다. 따라서 이 상수를 사용하기 전에 선언할 필요가 없습니다. 루프를 선언할 때 포함시키기만 해도 암묵적으로 선언한 셈이 됩니다. 즉 let 선언 키워드(declaration keyword)를 써줄 필요가 없습니다.  

>NOTE - 인덱스 상수는 루프의 스코프(scope)안에서만 존재합니다. 루프문이 끝난 다음에 이 인덱스의 값을 확인하고 싶거나, 이 값을 상수가 아니라 변수로 사용하고 싶으면, 루프 안에서 변수로 직접 선언해 주어야 합니다. 
 
 
범위 내에 있는 값이 필요 없다면, 변수명 대신에 언더바(`_`, underscore)를 써주면 됩니다:

```
  let base  = 3 
  let power  =  10 
  var answer  =  1 
  for _ in  1...power { 
     answer *= base 
  } 
println("\(base) to the power  of \(power) is \(answer)")  
println("\(base)를 \(power)번 곱한 것은 \(answer)이다")  

// prints "3 to the power of  10 is 59049"  
// prints “3의 10승은 59049입니다.”
```

위 예는 어떤 수의 몇 승을 계산해 줍니다(이 예에서는 3의 10승을 계산했습니다). 시작하는 값은 1인데(이는 3의 0승입니다), 이 시작하는 값에 다시 3을 곱해줍니다. 이 때 0에서 시작해서 9에서 끝나는 half-closed loop를 사용하였습니다. 이 계산을 수행할 때, 루프를 도는 동안 counter의 값은 필요 없습니다. 정확한 횟수만큼 루프를 도는 것만이 중요합니다. 밑줄(`_`, underscore)은 위 예에서 루프 변수 자리에 쓰였는데요, 그 결과 루프를 돌 때의 counter 현재값에 접근할 수 없게 됩니다.

배열 안에 들어 있는 항목(item)에 대해서 이터레이션(iteration)을 할 때에, `for-in` 루프를 사용하세요.

```
  let  names  = ["Anna", "Alex", "Brian", "Jack"] 
  for name in names { 
     println("Hello, \(name)!") 
  } 
 // Hello, Anna! 
 // Hello, Alex ! 
 // Hello, Brian! 
 // Hello, Jack!  
```


딕셔너리(dictionary)에 대해서도 이터레이션(iteration)을 해서 키-값 쌍(key-value pairs)에 접근할 수 있습니다. 딕셔너리에 대해서 이터레이션을 하면, 딕셔너리의 각 항목이 (key, value) 투플의 형태로 반환됩니다. 그리고 이 키-값 쌍은 쪼개어져서 두 개의 상수의 값으로 들어갑니다. 이 값은 `for-in` 루프 내의 본문(body)내에서 사용할 수 있습니다. 아래의 예에서 딕셔너리의 **키**는 animalName이라는 상수에, 딕셔너리의 **값**은 legCount라는 상수에 값으로 들어갑니다:

```
  let numberOfLegs  = ["spider": 8, "ant": 6, "cat": 4] 
  for (animalName, legCount) in numberOfLegs { 
     println("\(animalName)s have \(legCount) legs") 
  } 
 // spiders have 8 legs 
 // ants have 6 legs 
 // cats have 4 legs 
```
딕셔너리 안에 있는 항목이 이터레이션 될 때, 딕셔너리 안에 들어 있는 순서대로 되지는 않습니다. 딕셔너리 안에 들어 있는 데이터는 원래 정의상 순서가 없으며, 이터레이션을 돌 때에도, 어느 항목에 대해서 돌지 확신할 수 없습니다. 배열과 딕셔너리에 대해서 더 자세히 보시려면 컬렉션 형(Collection Types) 장을 참조하세요.


이 이터레이션 되는 순서는 고정되어 있지 않습니다. 딕셔너리 안에 들어 있는 순서대로  
배열과 딕셔너리 외에도, 문자열 내의 각 문자에 대해 이터레이션을 돌 때, `for-in` 루프를 사용할 수 있습니다:

```
 for character in "Hello" { 
     println(character) 
  } 
 // H 
 // e 
 // l 
 // l 
 // o  
```

## For-조건부-증가부 (For-Condition-Increment )

Swift는 `for-in`루프 말고도 C언어에서 쓰는, 조건부와 증가부가 들어 있는 `for` 루프를 지원합니다: 

```
 for var index  = 0; index  < 3; ++index { 
     println("index is \(index)") 
  } 
 // index is 0   // index is 1   // index is 2  
```
 다음은 이번에 다루는 루프 형식을 일반화해서 나타낸 것입니다.
 
 ```
        for   initialization ;   condition ;   increment  { 
              statements 
         }  
```
 
루프의 정의부는 세 부분으로 구성되는데, C언어에서처럼 각 부분을 세미콜론`;`으로 구분하고 있습니다. C언어와는 다르게 Swift에서는 "초기화;조건부;증가부" 부분을 괄호로 감싸주지 않아도 됩니다. 

다음은 루프가 실행되는 단계를 나타냅니다:

1. 처음 루프에 들어가면, 초기화 표현식(initialization expression)이 검토되고 루프를 도는 데 필요한 변수나 상수의 값을 지정합니다.
2. 조건 표현식(condition expression)을 검토합니다. 조건부가 거짓(false)이면, 루프는 종료하고, 코드 실행(code execution)은 루프를 닫는 중괄호(})다음 부분에서 계속됩니다. 조건부가 참(true)이면, 코드 실행은 루프를 여는 괄호({) 안에서 구문들을 실행합니다. 
3. 모든 구문이 실행된 후에는 증가부 표현식(increment expression)이 검토됩니다. 검토 결과 카운터의 값이 증가할 수도 있고 감소할 수도 있습니다. 또는 초기화되었던 변수의 값이 실행된 구문의 결과값에 근거하여 새로운 값으로 대체될 수도 있습니다.  증가부 부분이 검토된 후, 코드 실행은 2단계로 돌아가며, 조건 표현식이 다시 검토됩니다.

위에서 설명한 루프문의 형식(format)과 코드 실행 절차를 개요로 나타내면 다음과 같습니다:
```
         initialization 
        while   condition  { 
              statements 
              increment 
        }  
```
초기화 부분에서 선언된 상수와 변수(예를 들면 var index=0)는 `for` 루프 스코프 내에서만 사용할 수 있습니다. 루프가 끝난 후에도 index의 마지막 값에 접근할 수 있으려면, 루프 스코프가 시작하는 지점 이전에 index를 선언해주어야 합니다 (즉 루프 스코프의 바깥에서 선언해 주어야 합니다):

```
 var index : Int 			// <= 이 부분에서 선언해 주어야.. 
 for index  = 0; index  < 3; ++index { 
     println("index is \(index)") 
  } 
 // index is 0
 // index is 1 
 // index is 2 
  println("The loop statements were executed \(index) times") 
 // prints "The loop statements were executed 3 times"  
```

위 예에서 한 가지 주의할 점이 있습니다. 루프가 끝났을 때 index의 마지막 값은 2가 아니라 3입니다. 마지막으로 증가부(increment)가 실행되었을 때, index의 값은 3이 됩니다. index가 3이 되니, index < 3 조건부 false가 되서 루프가 끝난 것입니다. 




