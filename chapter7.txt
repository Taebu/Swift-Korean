# 07 흐름 제어  (Control Flow)
> Translator : 김나솔(nasol.kim@gmail.com)

Swift 언어에서는 C언어 같은 프로그래밍 언어에서 제공하는 것과 비슷한 제어문 관련 constructs를 제공합니다. 이러한 constructs에는 `for`나 `while`이 있으며, 이러한 키워드는 어떤 과제(task)를 여러 번 수행합니다. `if`와 `switch`문은 특정 조건이 충족되는지에 따라서 분기시켜서 코드 블럭을 실행시킵니다. 또한 `break`나 `continue` 같은 구문은 실행의 흐름을 코드 상의 다른 곳으로 이동시킵니다.

C언어에서는 `for`-조건부-증가(increment) 순환문(loop) 이런 방식을 전통적으로 사용하는데, Swfit에서는 `for-in` 순환문(loop)이라는 것이 있어서 배열이나 사전(dictionaries), ranges, 문자열(strings)등 sequence에 대해서iteration하기가 쉽습니다. 
 
C언어의 `switch`문과 비교했을 때, Swift의 `switch`문은 훨씬 더 강력합니다. Swift에서는 `switch`문이 "fall through" 하지 않습니다(역자주: fall through란, switch문에서 한 case에 대해서 처리하고 난 후 다음 case로 넘어가는 것). C언어에서는 실수로 `break`문을 써주지 않아서 에러가 생기는 경우가 있는데 Swift에서는 fall through 하지 않기 때문에 이런 에러를 방지할 수 있습니다. `swich`내의 case에 대해서 여러 종류의 pattern-maching을 사용할 수 있습니다. 수의 범위 match, 투플 match, casts to a specific type. `switch case`에서 match된 값을 임시 상수나 변수에 binding할 수도 있습니다. 이렇게 binding해두면 case의 본문(body) 내에서 이 상수나 변수를 사용할 수 있습니다. 또한 매칭 조건(matching condition)이 복잡한 경우에는, 각 case에 대해서 where절(where clause)을 사용해서 표현할 수 있습니다.  

## For 순환문(For Loops)

`for` 순환문(for loop) 사용하면 코드 블럭을 특정 횟수 만큼 수행할 수 있습니다. Swift에는 두 종류의 for 순환문이 있습니다:

* `for-in` : 어떤 범위나 sequence, collection, progression에 대해서, 이 안에 있는 각 항목(item)에 대해서 코드(a set of statement)를 실행합니다. 

* `for-condition-increment` : 특정 조건부가 참이 될 때까지 코드를 실행합니다. 보통 루프를 한 번 도는 것이 끝날 때마다 counter를 1씩 증가시킵니다.  

## For-In
 
여러 항목이 들어 있는 컬렉션(collection)이나, 어떤 범위, 배열 안에 들어 있는 항목(item)에 대해서, 또는 문자열에 들어 있는 각 문자에 대해서 iteration을 할 때 `for-in` loop를 사용합니다. 

다음의 예는 구구단의 5단에서 처음 몇 개를 출력해 줍니다: 
```
for index in  1...5 {       println("\(index) times 5 is \(index * 5)") 
 } 
// 1 times 5 is 5   
// 2 times 5 is  10   
// 3 times 5 is  15   
// 4 times 5 is 20   
// 5 times 5 is 25  
```

위 예에서는 범위가 1부터 5까지로 정해져 있고(closed range of numbers),  이 범위에 대해서 컬렉션(collection)안에 들어 있는 각 항목(item)에 대해 이터레이션을 돌고 있습니다. 단, 1...5라고 표현했을 때, ...(closed range operator)를 보면 알 수 있듯이, 이 범위에는 1과 5가 포함됩니다. 인덱스(index)의 값은 범위 내의 첫번째 수, 즉 1이 되며, 루프 내에 있는 구문이 실행됩니다. 위 예에서 루프 안에는 구문이 하나만 있습니다. 인덱스의 현재 값에 대해서 5단의 첫번째를 출력해주는 것입니다. 이 구문이 실행된 다음에 인덱스의 값은 범위 내의 두번째 값, 즉 2가 되도록 업데이트 됩니다. 그리고 printLn 함수가 다시 호출됩니다. 이 작업은 인덱스가 범위의 끝에 이를 때까지 계속됩니다.  

위 예에서 인덱스는 상수(constant)이며, 이 상수의 값은 루프를 돌 때마다, 초반에 자동으로 값이 지정됩니다. 따라서 이 상수를 사용하기 전에 선언할 필요가 없습니다. 루프를 선언할 때 포함시키기만 해도 암묵적으로 선언한 셈이 됩니다. 즉 let 선언 키워드(declaration keyword)를 써줄 필요가 없습니다.  

>NOTE - 인덱스 상수는 루프의 스코프(scope)안에서만 존재합니다. 루프문이 끝난 다음에 이 인덱스의 값을 확인하고 싶거나, 이 값을 상수가 아니라 변수로 사용하고 싶으면, 루프 안에서 변수로 직접 선언해 주어야 합니다. 
 
 
범위 내에 있는 값이 필요 없다면, 변수명 대신에 언더바(`_`, underscore)를 써주면 됩니다:

```
  let base  = 3 
  let power  =  10 
  var answer  =  1 
  for _ in  1...power { 
     answer *= base 
  } 
println("\(base) to the power  of \(power) is \(answer)")  
println("\(base)를 \(power)번 곱한 것은 \(answer)이다")  

// prints "3 to the power of  10 is 59049"  
// prints “3의 10승은 59049입니다.”
```

위 예는 어떤 수의 몇 승을 계산해 줍니다(이 예에서는 3의 10승을 계산했습니다). 시작하는 값은 1인데(이는 3의 0승입니다), 이 시작하는 값에 다시 3을 곱해줍니다. 이 때 0에서 시작해서 9에서 끝나는 half-closed loop를 사용하였습니다. 이 계산을 수행할 때, 루프를 도는 동안 counter의 값은 필요 없습니다. 정확한 횟수만큼 루프를 도는 것만이 중요합니다. 밑줄(`_`, underscore)은 위 예에서 루프 변수 자리에 쓰였는데요, 그 결과 루프를 돌 때의 counter 현재값에 접근할 수 없게 됩니다.

배열 안에 들어 있는 항목(item)에 대해서 이터레이션(iteration)을 할 때에, `for-in` 루프를 사용하세요.

```
  let  names  = ["Anna", "Alex", "Brian", "Jack"] 
  for name in names { 
     println("Hello, \(name)!") 
  } 
 // Hello, Anna! 
 // Hello, Alex ! 
 // Hello, Brian! 
 // Hello, Jack!  
```


딕셔너리(dictionary)에 대해서도 이터레이션(iteration)을 해서 키-값 쌍(key-value pairs)에 접근할 수 있습니다. 딕셔너리에 대해서 이터레이션을 하면, 딕셔너리의 각 항목이 (key, value) 투플의 형태로 반환됩니다. 그리고 이 키-값 쌍은 쪼개어져서 두 개의 상수의 값으로 들어갑니다. 이 값은 `for-in` 루프 내의 본문(body)내에서 사용할 수 있습니다. 아래의 예에서 딕셔너리의 **키**는 animalName이라는 상수에, 딕셔너리의 **값**은 legCount라는 상수에 값으로 들어갑니다:

```
  let numberOfLegs  = ["spider": 8, "ant": 6, "cat": 4] 
  for (animalName, legCount) in numberOfLegs { 
     println("\(animalName)s have \(legCount) legs") 
  } 
 // spiders have 8 legs 
 // ants have 6 legs 
 // cats have 4 legs 
```
딕셔너리 안에 있는 항목이 이터레이션 될 때, 딕셔너리 안에 들어 있는 순서대로 되지는 않습니다. 딕셔너리 안에 들어 있는 데이터는 원래 정의상 순서가 없으며, 이터레이션을 돌 때에도, 어느 항목에 대해서 돌지 확신할 수 없습니다. 배열과 딕셔너리에 대해서 더 자세히 보시려면 컬렉션 형(Collection Types) 장을 참조하세요.


이 이터레이션 되는 순서는 고정되어 있지 않습니다. 딕셔너리 안에 들어 있는 순서대로  
배열과 딕셔너리 외에도, 문자열 내의 각 문자에 대해 이터레이션을 돌 때, `for-in` 루프를 사용할 수 있습니다:

```
 for character in "Hello" { 
     println(character) 
  } 
 // H 
 // e 
 // l 
 // l 
 // o  
```

## For-조건부-증가부 (For-Condition-Increment )

Swift는 `for-in`루프 말고도 C언어에서 쓰는, 조건부와 증가부가 들어 있는 `for` 루프를 지원합니다: 

```
 for var index  = 0; index  < 3; ++index { 
     println("index is \(index)") 
  } 
 // index is 0   // index is 1   // index is 2  
```
 다음은 이번에 다루는 루프 형식을 일반화해서 나타낸 것입니다.
 
 ```
        for   initialization ;   condition ;   increment  { 
              statements 
         }  
```
 
루프의 정의부는 세 부분으로 구성되는데, C언어에서처럼 각 부분을 세미콜론`;`으로 구분하고 있습니다. C언어와는 다르게 Swift에서는 "초기화;조건부;증가부" 부분을 괄호로 감싸주지 않아도 됩니다. 

다음은 루프가 실행되는 단계를 나타냅니다:

1. 처음 루프에 들어가면, 초기화 표현식(initialization expression)이 검토되고 루프를 도는 데 필요한 변수나 상수의 값을 지정합니다.
2. 조건 표현식(condition expression)을 검토합니다. 조건부가 거짓(false)이면, 루프는 종료하고, 코드 실행(code execution)은 루프를 닫는 중괄호(})다음 부분에서 계속됩니다. 조건부가 참(true)이면, 코드 실행은 루프를 여는 괄호({) 안에서 구문들을 실행합니다. 
3. 모든 구문이 실행된 후에는 증가부 표현식(increment expression)이 검토됩니다. 검토 결과 카운터의 값이 증가할 수도 있고 감소할 수도 있습니다. 또는 초기화되었던 변수의 값이 실행된 구문의 결과값에 근거하여 새로운 값으로 대체될 수도 있습니다.  증가부 부분이 검토된 후, 코드 실행은 2단계로 돌아가며, 조건 표현식이 다시 검토됩니다.

위에서 설명한 루프문의 형식(format)과 코드 실행 절차를 개요로 나타내면 다음과 같습니다:
```
         initialization 
        while   condition  { 
              statements 
              increment 
        }  
```
초기화 부분에서 선언된 상수와 변수(예를 들면 var index=0)는 `for` 루프 스코프 내에서만 사용할 수 있습니다. 루프가 끝난 후에도 index의 마지막 값에 접근할 수 있으려면, 루프 스코프가 시작하는 지점 이전에 index를 선언해주어야 합니다 (즉 루프 스코프의 바깥에서 선언해 주어야 합니다):

```
 var index : Int 			// <= 이 부분에서 선언해 주어야.. 
 for index  = 0; index  < 3; ++index { 
     println("index is \(index)") 
  } 
 // index is 0
 // index is 1 
 // index is 2 
  println("The loop statements were executed \(index) times") 
 // prints "The loop statements were executed 3 times"  
```

위 예에서 한 가지 주의할 점이 있습니다. 루프가 끝났을 때 index의 마지막 값은 2가 아니라 3입니다. 마지막으로 증가부(increment)가 실행되었을 때, index의 값은 3이 됩니다. index가 3이 되니, index < 3 조건부 false가 되서 루프가 끝난 것입니다. 

## While 루프 (While Loops)

`while` 루프는 조건부가 거짓이 될 때까지 코드 블럭을 실행시킵니다. 이런 종류의 루프는 보통, 이터레이션이 시작하기 전에 이터레이션이 몇 번이나 돌 지 알지 못할 때 자주 사용합니다. Swift는 두 종류의 `while`루프를 지원합니다. 하나는 `while`인데, 이 루프는 루프를 돌기 시작할 때 조건부를 검토합니다. 다른 하나는 `do-while`인데, 이 루프는 루프를 돌고 나서 조건부를 검토합니다. 

### While 

`while` 루프는 한 개의 조건부를 검토하는 것에서 시작합니다. 조건부가 참이면, 코드가 실행되며, 조건부가 거짓이 될 때까지 반복해서 실행됩니다.
다음은 `while`루프를 일반화해서 나타낸 것입니다:

```
       while   condition  { 
             statements 
       }  
```
       
이번에 사용할 예제는 뱀과 사다리 게임입니다.
 
[그림 삽입]

게임의 규칙은 다음과 같습니다:

* 게임판에는 25개의 칸이 있으며, 목표는 25번 칸에 도달하거나 이를 넘는 것입니다. 
* 자기 차례가 오면, 참가자는 6면 주사위를 던지고 나온 수 만큼 점선으로 표시된 경로를 따라서 이동합니다. 
* 이동했을 때, 사다리의 아랫 부분에 도달하면, 사다리를 타고 올라갑니다.
* 이동했을 때 뱀의 머리에 도달하면, 뱀을 타고 내려갑니다. 

게임판은 정수값 (Int values)으로 나타냅니다. 게임판의 크기는 finalSquare 상수로 정합니다. finalSquare는 배열을 초기화할 때 사용하며, 나중에 게임에 이겼는지 여부를 판별할 때도 사용합니다. 배열 board는 26개의 정수값 0으로 초기화됩니다. 25개가 아닙니다. (0부터 25까지, 26개입니다.)

```
 let finalSquare  = 25 
 var board  = Int[](count : finalSquare +  1, repeatedValue: 0)  
```
 
몇몇 칸에는 0이 아니라 특정한 값이 지정됩니다. 이 값은 뱀과 사다리 때문에 필요한 값입니다. 사다리의 밑부분이 들어 있는 칸은 게임판에서 앞으로 이동시키는 만큼의 양수(positive number)를 포함하고, 뱀 머리가 들어 있는 칸은 게임판에서 뒤로 이동시키는 만큼의 음수(negative number)를 포함합니다: 

```
 board[03] = +08; board[06] = +11; board[09] = +09; board[10] = +02 
 board[14] = -10; board[19] = -11; board[22] = -02; board[24] = -08  
```

3번 칸은 사다리의 밑 부분을 포함합니다. 여기에 가면 참가자는 11번 칸으로 이동합니다. 이것을 나타내기 위해서 board[03]에 +08 값을 지정합니다. 이는 정수값 8과 동일합니다(11과 3간의 차이). 단항 연산자인 plus operator(+i)는 단항 연산자 minus operator(-i)와 균형을 이룹니다. 또한 10보다 작은 수에는 10자리에 0을 넣어서(예: 8 -> 08) 줄이 맞추어져 가지런하게 보이도록 했습니다.

(이처럼 0을 넣는 등 스타일에 변화를 주는 것은 꼭 필요한 것은 아닙니다만, 이렇게 하면 코드가 더 깔끔하게 보입니다.)

 
게임 참가자가 시작하는 칸은 "0번 칸"이며, 이 칸은 게임판의 좌측 하단 바깥에 있습니다. 주사위를 처음 던지면, 참가자는 항상 게임판 위로 이동하게 됩니다: 

```
 var square  = 0 
 var diceRoll   = 0 
 while square < finalSquare { 
     // 주사위를 던진다
     if ++diceRoll  == 7 { diceRoll  =  1 } 
     // 주사위를 던져 나온 수 만큼 이동한다
     square += diceRoll  
     if square  < board.count { 
         // 아직 게임판에 있다면, 뱀을 타고 내려가거나 사다리를 타고 올라간다
        //if we're still on the board, move up or down for a snake or a ladder  
 square += board[square] 
("Game over!")  
```

이 예제에서는 주사위를 던지는 부분을 간단하게 처리했습니다. 난수를 발생시키지 않고, diceRoll의 값을 0에서 시작하게 하고, 루프를 돌 때마다, diceRoll 값이 1씩 증가하도록 했습니다. ++i (prefix increment operator)를 사용해서 말이죠. 그런 다음에 diceRoll의 값이 너무 크지 않은지 확인했습니다. ++diceRoll 값은 diceRoll이 1만큼 증가한 값과 같습니다. ++diceRoll 값이 7과 같아지면, 값이 너무 커진 것이며, 이 때 diceRoll 값을 1로 해줍니다. 이렇게 하면 diceRoll의 값은 항상 1,2,3,4,5,6,1,2, 등등의 값을 가지게 됩니다.

주사위를 던진 후에, 게임 참가자는 diceRoll 값 만큼 칸을 이동합니다. 주사위에서 나온 수만큼 이동했는데, 참가자가 25번 칸을 넘어가는 경우가 생길 수 있습니다. 이 경우에는 게임이 끝납니다. 이 시나리오를 따르기 위해서, 코드는 현재의 칸 번호(square) 값에다 board[squre]에 저장된 값을 더해서 참가자를 이동시키기 전에, 칸 번호가 board 배열의 count 값보다 작은지 확인합니다.  

이렇게 확인작업을 해주지 않으면, board[squre]라고 썼을 때 board 배열의 범위를 넘어서는 값을 접근하려고 시도하게 됩니다.


이렇게 확인작업을 해주지 않으면, board[squre]라고 썼을 때 board 배열의 범위를 넘어서는 값을 접근하려고 시도하게 되고, 에러가 날 것입니다. 예를 들어 칸 번호(square)가 26과 같아지면, 코드는 board[26]의 값을 확인하려 할 것이고, 26은 배열의 수보다 큽니다.
이 `while` 루프 실행은 끝납니다. 그리고 루프의 조건부를 확인하고, 루프가 다시 실행되어야 하는지 확인합니다. 게임참가자가 25번 칸이나 25를 넘어서는 칸으로 이동했다면, 루프의 조건부는 거짓이 될 것이고 게임은 끝납니다. 
  위 예제의 경우에는 `while`루프를 사용하는 것이 적절합니다. 왜냐하면 `while` 루프가 시작되기 전에 게임가 얼마나 계속되어야 하는지 알지 못하기 때문입니다. `while` 루프를 쓰면 특정 조건이 충족될 때까지 계속해서 실행됩니다. 

### Do-While

`while`루프와 비슷하지만 약간 다른 루프도 있습니다. 이름은 `do-while`루프이며, 이 루프에서는 루프의 조건부가 검토되기 전에 루프 블록이 한 번 실행됩니다. 그런 다음 조건부가 거짓이 될 때까지 루프를 반복합니다. 

다음은 `do-while`문을 간단하게 일반화하여 나타낸 것입니다:

```
        do { 
              statements 
        } while   condition  
```
이번에도 뱀과 사다리 게임 예제를 사용하겠습니다. 다만 이번에는 `while` 루프 가 아니라 `do-while` 루프를 사용합니다. finalSquare, board, square, diceRoll 변수의 값은 앞에서 `while`루프를 사용했을 때와 동일한 값을로 초기화했습니다.

```
 let finalSquare  = 25 
 var board  = Int[](count : finalSquare +  1, repeatedValue: 0) 
 board[03]  = +08; board[06]  = +11; board[09]  = +09; board[10]  = +02   board[14]  = -10; board[19]  = -11; board[22]  = -02; board[24]  = -08 
 var square  = 0 
 var diceRoll  = 0  
```

이번 예제에서, 루프 내에서 처음으로 하는 작업은 사다리나 뱀이 들어 있는 지 확인하는 것입니다. 사다리를 타고 올라갔을 때 게임 참가자가 바로 25번 칸으로 이동하는 것은 불가능합니다. 즉 사다리를 타는 방법으로는 게임에서 이길 수 없습니다. 따라서 루프 안에서 칸에 뱀이나 사다리가 있는 지 여부를 확인하면 안전합니다. 

게임을 시작할 때, 참가자는 “0번 칸”에 있습니다. board[0]의 값은 항상 0이며, 이 값이 가지는 효과는 없습니다: 

```
do { 
     // move up or down for a snake or ladder square += board[square] 
// 주사위를 던진다
     if ++diceRoll  == 7 { diceRoll  =  1 } 
// 주사위를 던져서 나온 수만큼 이동한다
     square += diceRoll 
 } while square  < finalSquare 
println("Game over!")  
```

칸에 뱀이나 사다리가 있는지 프로그램이 확인한 후에, 주사위가 던져집니다. 게임 참가자는 diceRoll 값 만큼 칸을 움직입니다. 그런 다음 이번 루프 실행은 끝납니다. 

루프의 조건부의 내용( while square < finalSquare)은 이전 예제에서와 같지만, 이번에는 루프를 한 번 돈 다음에 이 조건부가 검토됩니다. 이 게임에는 `while`루프보다 `do-while` 루프의 구조가 더 적절합니다. 이번에 사용한 `do-while` 루프에서, square += board[quare] 이 부분은 루프의 while 조건부에서 square가 아직 board 상에 있다고 확인한 후에 항상 즉시 실행됩니다.  이렇게 하면 이전 예제에서 한 것처럼 배열의 범위를 확인할 필요가 없어집니다.
 
## 조건문  (Conditionals Statements)

특정 조건이 충족하는지에 따라 각각 다른 코드를 실행하는 것이 유용한 경우가 많습니다. 어떤 에러가 발생했을 때 특정 코드를 실행시키고 싶을 수도 있습니다. 또는 어떤 값이 너무 높거나 너무 낮을 때 메시지를 보여주고 싶을 수도 있습니다. 이렇게 하려면 코드를 조건문으로 쓰면 됩니다.

Swift에서 코드에 조건문을 추가하는 방법은 두 가지가 있습니다. 바로 `if`문과 `switch`문입니다. 보통 조건의 수가 많지 않을 때에는 보통 `if`문을 사용합니다. 한편 조건의 종류가 다양하고 복잡할 때에는 `switch`문이 더욱 적합하니다. 실행시킬 코드 브랜치를 선택하는데 패턴-매칭이 도움이 되는 경우에도 `switch`문을 사용합니다. 

### If

`if`문을 아주 단순하게 표현하면, 하나의 `if` 조건이 있습니다. 그럼 그 조건이 참인 경우에만 코드구문들이 실행됩니다. 

```
 var temperatureInFahrenheit  = 30    if temperatureInFahrenheit  <= 32 { 
      println("It's very cold. Consider wearing a scarf.") 
  } 
 // prints "It's very cold. Consider wearing a scarf."  
```

위 예제에서는 온도가 화씨 32도(물이 어는 온도)보다 낮은지 같은지 여부를 확인합니다. 온도가 화씨 32도 이하이면, 메시지가 출력됩니다. 그 외의 경우에는 아무런 메시지도 나오지 않으며 코드 실행은 `if`문을 닫는 중괄호(}) 다음으로 이동하여 계속됩니다.

`if`문을 사용할 때에는 `else` 절도 사용할 수 있는데, 여기에는 `if` 조건이 거짓일 때 실행되는 코드가 들어갑니다. `else` 키워드를 사용하여 나타냅니다:

```
  temperatureInFahrenheit  = 40 
  if temperatureInFahrenheit  <= 32 { 
      println("It's very cold. Consider wearing a scarf.") 
  } else { 
      println("It's not that cold. Wear a t-shirt.") 
  } 
 // prints "It's not that cold. Wear a t-shirt."  
```
 
위에서 두 개의 브랜치 중에서 하나는 항상 실행됩니다. 온도가 화씨 40도로 올라갔기 때문에, 스카프를 매라고 조언할 정도로 춥지 않습니다. 따라서 `else` 브랜치가 대신에 실행됩니다. 

추가적인 경우를 고려할 때에는 여러 개의 `if`문을 쓸 수도 있습니다:

```
  temperatureInFahrenheit  = 90 
  if temperatureInFahrenheit  <= 32 { 
      println("It's very cold. Consider wearing a scarf.") 
  } else if temperatureInFahrenheit  >= 86 { 
      println("It's really warm. Don't forget to wear sunscreen.") 
  } else { 
      println("It's not that cold. Wear a t-shirt.") 
  } 
 // prints "It's really warm. Don't forget to wear sunscreen."  
```

위 예에서, 추가적인 `if` 문이 들어갔습니다. 이 부분은 온도가 특별히 높을 때의 경우에 대한 것입니다. 

마지막에 쓴 `else` 절이 있습니다. 이 부분은 온도가 너무 높지도 낮지도 않은 경우에 보여주는 메시지를 출력합니다. 

하지만 마지막에 쓴 `else` 절은 선택적입니다. 조건들이 모든 경우를 다뤄야 하지 않는다면, `else`절을 안 써줘도 됩니다:

```
  temperatureInFahrenheit  = 72 
  if temperatureInFahrenheit  <= 32 { 
     println("It's very cold. Consider wearing a scarf.") 
  } else if temperatureInFahrenheit  >= 86 { 
     println("It's really warm. Don't forget to wear sunscreen.") 
  }  
```
 
이번 예제에서 온도는 너무 낮지도 너무 높지도 않았습니다. 그래서 `if`나 `else if`조건부에 들어 있는 코드는 실행되지 않았습니다. 그리고 아무 메시지도 출력되지 않았습니다: 
             


