# 08 함수 (Functions)
> Translator : 이름 (메일주소)

함수는 특정 일을 수행하는 자기 완결성(Self-contained)을 가진 코드들의 집합입니다. 당신은 함수의 이름을 지으면서 이 함수가 무엇을 하는지 식별하게 할 수 있습니다. 그리고 그 이름으로 함수를 "호출(Call)"하여 필요할때 함수의 일을 수행하게 만들 수 있습니다.
스위프트(Swift)의 함수 문법은 파라메터가 없는 C스타일의 함수에서부터 지역 파라메터와 파라메터 이름 각각에 대한 외부 파라메터를 가지고 있는 복잡한 오브젝티브-C 스타일의 함수까지 전부 표현할 수 있습니다. 파라메터는 기본 값을 가질수 있어 단순한 함수 호출에 쓰일수 있습니다. 또한 In-out 파라메터로서 변수를 넘겨 변수가 함수의 실행후에 파라메터가 변경되게 할 수도 있습니다.
파라메터 타입과 반환(Return) 타입으로 이루어진 모든 스위프트의 함수들은 타입을 가집니다. 스위프트에 있는 다른 타입들과 마찬가지로, 함수의 타입들을 사용할 수 있습니다. 즉 함수를 다른 함수에 파라메터로서 넘겨주거나 함수를 다른 함수에서 반환받을 수 있습니다. 함수들은 유용한 기능 캡슐화를 위해 중첩된 함수안의 범위 내에서 쓰여질수도 있습니다.

## 함수 정의와 호출
함수를 정의할때 함수의 입력(파라메터)을 하나 이상의 이름이 있고 타입이 정해진 값으로 할 수 있습니다. 또한 값의 타입은 함수의 실행이 끝났을때 함수가 되돌려줄 수 있습니다 (반환 타입).
모든 함수는 함수명을 가지고 있으며, 함수명은 함수가 하는일을 설명해줍니다. 함수를 사용하기위해서 함수를 함수의 이름을 사용하여 "호출"하고 함수의 파라메터 타입들과 일치하는 입력 값들(아규먼트Arguments)을 넘겨줍니다. 함수의 입력값은 함수의 파라메터리스트와 언제나 일치해야합니다.
아래의 함수 예제 이름은 `greetingForPerson`입니다. 함수가 행하는 일이 바로 그것(사람에게 환영인사Greeting for person)이기 때문입니다. 입력으로 사람의 이름을 받아서 그 사람에 대한 환영 인사를 반환합니다. 이를 달성하기 위해 파라메터를 하나 정의하고 - `personName`이라는 `String` 값 - 반환 타입을 `String`으로 합니다. 그렇게 그 사람에 대한 인사를 포함하는 것입니다.

```
func sayHello(personName: String) -> String {
  let greeting = "Hello, " + personName + "!"
  return greeting
}
```
이 모든 정보들은 func 키워드 접두어를 쓰는 함수의 정의안에 포함이 되게도비니다. 함수의 반환 타입은 화살표(하이픈과 우측 꺽괄호) `->`를 사용하여 화살표 오른쪽에 표시합니다.
함수 정의는 함수가 무엇을 하는지, 무엇을 파라메터로 받는지 완료되었을때 무엇을 반환하는지 설명합니다. 함수 정의는 함수가 코드안에서 호출될때 명확하고 애매함이 없는 방법으로 사용될수 있게합니다:

```
println(sayHello("Anna"))
// prints "Hello, Anna!"
println(sayHello("Brian"))
// prints "Hello, Brian!"
```
`sayHello` 함수를 괄호안에 `String` 타입의 인수를 넣어서 호출합니다. 예를들면 `sayHello("Anna")` 처럼 말이죠. `sayHello`가 `String`타입을 반환하기에 `sayHello`함수는 println로 싸여서 호출될 수 있습니다. 이렇게 함으로서 println함수가 sayHello함수의 반환값을 위에 보이는 것처럼 출력할 수 있습니다.
`sayHello`함수의 몸체는 `greeting`이라는 새 `String` 상수를 선언하는 것으로 시작합니다. 그리고 `greeting`을 `personName`에 대한 단순한 환영인사로 설정합니다. 이 환영 인사는 `return`키워드를 통해 함수의 밖으로 되돌려지게 됩니다. `return greeting`이 실행 되면 함수의 실행은 끝나게되고, `greeting`의 현재 값을 돌려주게됩니다.
`sayHello` 함수를 다른 입력값으로 여러번 호출할 수 있습니다. 위의 예제는 입력값이 "Anna", "Brian" 일때를 각각 보여주고 있습니다. 함수는 사람(입력값)에 맞게끔 환영인사를 각각의 경우에 맞추어 돌려줍니다.
함수 몸체를 단순화하기 위해서는, 메시지의 생성과 반환을 한줄로 합치면 됩니다:
```
func sayHelloAgain(personName: String) -> String {
	return "Helloagain, " + personName + "!"
}
println(sayHelloAgain("Anna"))
// prints "Helloagain, Anna! 
```
## 함수 파라메터와 반환값
스위프트에서 함수 파라메터와 반환값은 극도로 유연합니다. 이름없는 파라메터를 사용하는 단순한 기능성 함수에서부터 명시적 파라메터 이름(expressive parameter names)과 다른 파라메터 옵션을 가진 복잡한 함수에 이르기까지 무엇이든 정의할수 있습니다.

## 파라메터 복수 입력
함수는 괄호 안에서 콤마로 구분되는 복수의 입력 파라메터를 가질수 있습니다. 
이 함수는 반개영역(half-open range)의 시작과 끝의 인덱스를 받아 얼마나 많은 요소(elements)들이 영역안에 있는지 계산합니다:

    func halfOpenRangeLength(start: Int, end: Int) -> Int {
    	return end - start
    }
    println(halfOpenRangeLength(1, 10))
    // prints "9"

## 파라메터가 없는 함수
함수에 입력 파라메터를 정의할 필요는 없습니다. 밑의 예제는 입력 파라메터가 없는 함수입니다. 이 함수는 호출될때마다 언제나 같은 메시지를 반환합니다.

    func sayHelloWorld() -> String {
	    return "hello, world"
    }
    println(sayHelloWorld())
    // prints "hello, world"
    
함수 정의는 아무런 파라메터를 받지 않는다고 해도 함수 이름뒤에 여전히 괄호를 포함해야 합니다. 함수가 호출될 때도 함수 이름뒤에 빈 괄호 한쌍이 따라와야합니다.

## 반환값이 없는 함수
함수에 반환 타입을 정의할 필요는 없습니다. 밑의 예제는 `sayHello`의 `waveGoodbye`라 불리는 버전입니다. 값을 반환하지 않고 자신만의 `String`값을 출력합니다.

    func sayGoodbye(personName: String) {
	    println("Goodbye, ` \(personName)! ")
    }
    sayGoodbye("Dave")
    // prints "Goodbye, Dave!"
    
반환값을 필요로 하지 않기 때문에 함수 정의는 반환 화살표(return arrow)나 반환 타입을 포함하지 않습니다.

> N O T E
엄밀히 말하자면, `sayGoodbye` 함수는 반환값이 정의되어있지 않아도 여전히 반환값을 가집니다.  반환값이 정의되어있지 않은 함수는 `Void`타입의 특수값을 반환합니다. '()'로 쓰여질수 있는 단순한 빈 튜플(Tuple)이며, 사실상 요소를 갖고있지 않은 튜플입니다.

함수가 호출되었을때 함수의 반환값은 무시될수 있다.
```
func printAndCount(stringToPrint: String) -> Int {
  println(stringToPrint)
  return countElements(stringToPrint)
}
func printWithoutCounting(stringToPrint: String) {
	printAndCount(stringToPrint)
}
printAndCount("hello, world")
// prints "hello, world" and returns a value of 12
printWithoutCounting("hello, world")
// prints "hello, world" but does not return a value
```
첫번째 함수인 `printAndCount`는 문자열을 출력하고 출력한 문자열의 캐릭터 갯수를 세서 Int 타입으로 반환합니다. 두번째 함수인 `printWithoutCounting`은 첫번째 함수를 호출합니다. 하지만 반환값은 무시합니다. 두번째 함수가 호출되면 메시지는 첫번째 함수에 의해 여전히 출력되지만, 첫번째 함수의 반환값은 사용되지 않습니다.

> N O T E
반환값은 무시될수 있습니다. 하지만 함수는 언제나 값을 반환할것입니다. 반환 타입이 정의된 함수는 값을 반환하지 않은채로 함수가 실행 될수 없습니다. 그렇게 하려고 시도할 경우 컴파일 에러를 낼 것입니다. 

## 여러개의 반환값을 가지는 함수
튜플 타입은 하나의 합성된 반환값으로서 함수의 반환에 사용될 수 있습니다.
아래의 예제는 `count`라는 함수의 정의입니다. 이 함수는 아메리칸 영어에서 사용되는 표준 모음과 자음을 기반으로 모음과 자음 그리고 다른 문자들을 문자열안에서 셉니다.
```
func count(string: String) -> (vowels: Int, consonants: Int, others: Int) {
  var vowels = 0, consonants = 0, others = 0
  for character in string {
    switch String(character).lowercaseString {
      case "a", "e", "i ", "o", "u":
      ++vowels
      case "b", "c", "d", "f", "g", "h", "j", "k", "l ", "m",
      "n", "p", "q", "r", "s", "t", "v", "w ", "x", "y", "z":
      ++consonants
      default:
      ++others
    }
  }
  return (vowels, consonants, others)
}
```
이 count 함수를 이용함으로서 임의의 문자열의 문자 갯수를 셀수 있습니다.  그리고 세 개의 이름있는 Int 값으로 구성된 튜플로 그 값을 받아옵니다.
```
let total  = count("some arbitrary string! ")
println("\(total.vowels) vowels and \(total.consonants) consonants")
// prints "6 vowels and 13 consonants"
```
튜플의 멤버들은 함수 내에서 반환할때 이름을 지을 필요가 없습니다. 함수 정의시에 함수의 반환 타입에 이미 명시가 되어있기 때문입니다. 

## 함수 파라메터 이름
위의 모든 함수들은 함수 자신의 파라메터로 파라메터 이름을 정의하고 있다.
```
func someFunction(parameterName: Int) {
  // function body goes here, and can use parameterName
  // to refer to the argument value for that parameter
}
```
하지만 그러한 파라메터 이름들은 오직 함수 자신의 몸체(Body) 안에서만 사용될 수 있습니다. 또한 함수를 호출할때는 사용할 수 없습니다. 그러한 종류의 파라메터 이름은 지역 파라메터 이름(local parameter names)이라고 합니다. 오직 함수의 내부(Body)에서만 사용할 수 있기 때문입니다.

## 외부 파라메터 이름(External Parameter Names)
때때로 각각의 파라메터의 이름을 함수를 호출할때 지어주는 것이 유용할때가 있습니다. 함수에게 어떤 인수가 어떤 목적인지 지시하기 위해서죠.
만약 당신이 만든 함수를 사용하려는 사용자에게 파라메터 이름을 제공하고 싶다면, 지역 파라메터 이름과 외부 파라메터 이름을 정의하면 됩니다. 외부 파라메터 이름은 지역 파라메터 이름 바로 앞에 공백으로 구분해서 작성합니다.
```
func someFunction(external ParameterName localParameterName: Int) {
  // function body goes here, and can use local ParameterName
  // to refer to the argument value for that parameter
}
```
> N O T E
만약 외부 파라메터 이름이 파라메터에 대해 제공된다면, 외부 파라메터 이름은 언제나 함수 호출시에 사용되어야 합니다.

예를 들어 다음과 같은 함수가 있다고 합시다. 이 함수는 두 문자열 사이에  `joiner` 문자열을 삽입해 연결하는 함수입니다.

    func join(s1: String,  s2: String,  joiner: String) -> String {
  		  return s1 + joiner + s2
    }
    
이 함수를 호출할때 함수로 전달되는 세 문자열의 목적이 불분명합니다.

    join("hello", "world", ", ")
    // returns "hello, world"

문자열 값들의 목적을 명확하게 하기 위해, 외부 파라메터를 join함수의 각각의 파라메터에 정의합니다.

```
func join(string s1: String,  toString s2: String,  withJoiner joiner: String) -> String {
	return s1 + joiner + s2
}
```
 
이 버전의 join 함수에서는 첫번째 파라메터의 외부 이름은 `string`이며 지역 이름은 `s1`이다. 두번째 파라메터는 외부 이름으로 `toString`을 쓰고 지역 이름은 `s2`이다. 그리고 세번째 파라메터는 외부 이름으로 `withJoiner`를 쓰고 지역 이름은 `joiner`이다.
이제 외부 파라메터 이름을 사용하여 함수를 호출할때 명확하고 애매하지 않은 방법으로 호출할 수 있게 되었다.

    join(string: "hello",  toString: "world",  withJoiner: ", ")
    // returns "hello, world"
    
외부 파라메터 이름의 사용은 이 두번째 join함수를 명시적이며 말이 되는(sentence-like) 방법으로 사용자들이 호출할 수 있게 합니다. 함수 몸체는 여전히 가독성이 좋고 명확한 의도를 가진채 말이죠. (whi le sti l l providing a function body that is readable and clear in intent.)

>N O T E
누군가가 당신의 코드를 처음 보았을때 명확하지 않을 수 있다면 외부 파라메터 이름을 쓰는것을 언제나 고려하십시오. 만약 함수가 호출될때 각각의 파라메터들의 목적이 명확하고 모호하지 않다면 외부 파라메터 이름을 정할 필요는 없습니다.

## 단축 외부 파라메터 이름
만약 함수의 외부 파라메터 이름을 제공하려 할때 이미 해당 파라메터의 내부 이름(local parameter name)이 이미 적절한 이름을 가지고 있다면, 똑같은 이름을 두번 쓸 필요가 없다. 대신 파라메터 이름을 한번 쓰고, 이름의 접두어로 해시 심볼(hash symbol) (`#`)을 붙인다. 이렇게 함으로서 스위프트는 해당 이름을 외부 파라메터 이름과 지역 파라메터 이름으로 동시에 쓰게 될 것이다.
이 예제는 `containsCharacter` 함수를 정의하고 호출한다. 해당 함수는 두 입력 파라메터에 `#`을 붙여서 같은 이름으로 외부 파라메터 이름과 내부 파라메터 이름으로 쓰이게 하였다.
```
func containsCharacter(#string: String,  #characterToFind: Character) -> Bool {
  for character in string {
    if character == characterToFind {
    	return true
    	}
    }
  return false
  }
```
이 함수의 파라메터 이름 선정은 함수 몸체를 명확하고 가독성있게 하며 동시에 함수 호출에 모호함이 없게 하였다.
```
let containsAVee = containsCharacter(string: "aardvark", characterToFind: "v")
// containsAVee equals true,  because "aardvark" contai ns a "v"
```
## 기본(default) 파라메터 값
함수 정의의 일부로서 파라메터의 기본 값을 지정해줄 수 있다. 기본값이 지정되어 있으면 함수를 호출할때 해당 파라메터를 생략할 수 있다.

>N O T E
기본값을 가지는 파라메터는 함수의 파라메터 리스트에서 마지막에 둔다. 이렇게 함으로써 함수 호출이 기본값을 가지지 않는 파라메터들이 언제나 같은 순서임을 보장할 수 있고, 매번 함수가 호출될 때마다 같은 함수가 호출되게 한다.

앞서 보인 `join`함수의 `joiner` 파라메터에 기본값을 부여한 버전이 있다.
```
func join(string s1: String, toString s2: String, withJoiner joiner: String = " ") 
-> String {
	return s1 + joiner + s2
}
```
만약 `join`함수의 `joiner` 문자열 값이 주어지면, 앞서 보았던 것처럼 해당 문자열 값이 두 문자열을 붙이는데 사용된다.
```
join(string: "hello", toString: "world", withJoiner: "-")
// returns "hello-world
```
하지만 아무런 값이 `joiner`에 주어지지 않는다면, 기본값인 공백 한칸 (`" "`)이 대신 사용된다.
```
join(string: "hello", toString: "world")
// returns "hello world"
```
## 기본값을 가지는 외부 파라메터 이름
대부분의 경우 외부 파라메터 이름에 기본값을 제공(외부 파라메터이기에 요구되기도 하는)하는 것은 유용하다. 그렇게 함으로써 함수가 호출될때 인수가 파라메터에 대해 가지는 목적이 명확해진다.
이 과정을 쉽게 하기위해, 외부 이름을 부여하지 않은 파라메터에 대해 스위프트는 자동 외부 이름을 기본값이 정의되어 있는 파라메터에 대해 제공한다. 자동 외부 이름은 지역 이름과 똑같다. 앞서 본 해시 심볼(`#`)을 사용한 것처럼.
여기에 `joiner` 문자열 값에 기본값을 부여하였지만, 파라메터 일체에 외부 파라메터 이름은 주지 않은 버전의 `join`함수가 있다.
```
func join(s1: String, s2: String, joiner: String = " ") -> String {
	return s1 + joiner + s2
}
```
이 경우에 스위프트는 자동적으로 외부 파라메터 이름을 기본값이 있는 파라메터 `joiner`에 대해 부여한다. 그러므로 외부 이름은 반드시 함수가 호출 될 때에 제공되어야 하며, 파라메터의 목적을 명확하고 모호하지 않게 한다.
```
join("hello", "world", joiner: "-")
// returns "hello-world"
```
>N O T E
함수를 정의할때 명시적인 외부 이름을 쓰는 것 대신에 밑줄(`_`)을 씀으로써 이 동작을 수행하지 않게 할 수 있다. 하지만 기본값을 가진 파라메터에 적절한 외부 이름을 제공하는것은 언제나 바람직하다.

## Variadic Parameters
A variadi c parameter accepts zero or more values of a speci fied type. You use a variadi c
parameter to speci fy that the parameter can be passed a varying number of input values
when the function i s cal led. Wri te variadi c parameters by inserting three period
characters (. . .) after the parameter’s type name.
The values passed to a variadi c parameter are made avai lable wi thin the function’s body
as an array of the appropriate type. For example, a variadi c parameter wi th a name of
numbers and a type of Doubl e. . .  i s made avai lable wi thin the function’s body as a constant
array cal led numbers of type Doubl e[].
The example below cal culates the ari thmeti c mean (al so known as the average) for a l i st
of numbers of any length:
func ari thmeti cMean(numbers: Doubl e. . . ) -> Doubl e {
var total : Doubl e = 0
for number i n numbers {
total  += number
}
return total  / Doubl e(numbers. count)
}
ari thmeti cMean(1,  2,  3,  4,  5)
// returns 3. 0,  w hi ch i s the ari thmeti c mean of these fi ve numbers
meti cMean(3,  8,  19)
turns 10. 0,  w hi ch i s the ari thmeti c mean of these three numbers
> N O T E
A functi on may have at most one vari adi c parameter,  and i t must al w ays appear l ast i n the parameter l i st,  to
avoi d ambi gui ty w hen cal l i ng the functi on w i th mul ti pl e parameters.
If your functi on has one or more parameters w i th a defaul t val ue,  and al so has a vari adi c parameter,  pl ace
the vari adi c parameter after al l  the defaul ted parameters at the very end of the l i st.

## Constant and Variable Parameters
Function parameters are constants by defaul t. Trying to change the value of a function
parameter from wi thin the body of that function resul ts in a compi le-time error. Thi s
means that you can’t change the value of a parameter by mi stake.
However, sometimes i t i s useful  for a function to have a variable copy of a parameter’s
value to work wi th. You can avoid defining a new variable yoursel f wi thin the function by
speci fying one or more parameters as variable parameters instead. Variable parameters
are avai lable as variables rather than as constants, and give a new modi fiable copy of the
parameter’s value for your function to work wi th.
Define variable parameters by prefixing the parameter name wi th the keyword var:
func al i gnRi ght(var stri ng: Stri ng,  count: Int,  pad: Character) -> Stri ng {
l et amountT oPad = count -  countEl ements(stri ng)
for _ i n 1. . . amountT oPad {
stri ng = pad + stri ng
}
return stri ng
}
l et ori gi nal Stri ng = "hel l o"
l et paddedStri ng = al i gnRi ght(ori gi nal Stri ng,  10,  "-")
addedStri ng i s equal  to "- - - - -hel l o"
i gi nal Stri ng i s sti l l  equal  to "hel l o"
Thi s example defines a new function cal led al i gnRi ght, whi ch al igns an input string to the
right edge of a longer output string. Any space on the left i s fi l led wi th a speci fied
padding character. In thi s example, the string "hel l o" i s converted to the string "- - - - -hel l o".
The al i gnRi ght function defines the input parameter stri ng to be a variable parameter. Thi s
means that stri ng i s now avai lable as a local  variable, ini tial i zed wi th the passed-in string
value, and can be manipulated wi thin the body of the function.
The function starts by working out how many characters need to be added to the left of
stri ng in order to right-al ign i t wi thin the overal l  string. Thi s value i s stored in a local
constant cal led amountT oPad. The function then adds amountT oPad copies of the pad character
to the left of the exi sting string and returns the resul t. It uses the stri ng variable parameter
for al l  i ts string manipulation.

>N O T E
T he changes you make to a vari abl e parameter do not persi st beyond the end of each cal l  to the functi on,
and are not vi si bl e outsi de the functi on’s body.  T he vari abl e parameter onl y exi sts for the l i feti me of that
functi on cal l .

## In-Out Parameters
Variable parameters, as described above, can only be changed wi thin the function i tsel f.
If you want a function to modi fy a parameter’s value, and you want those changes to
persi st after the function cal l  has ended, define that parameter as an in-out parameter
instead.
You wri te an in-out parameter by placing the i nout keyword at the start of i ts parameter
defini tion. An in-out parameter has a value that i s passed in to the function, i s modi fied
by the function, and i s passed back out of the function to replace the original  value.
You can only pass a variable as the argument for an in-out parameter. You cannot pass a
constant or a l i teral  value as the argument, because constants and l i teral s cannot be
modi fied. You place an ampersand (&) di rectly before a variable’s name when you pass i t
as an argument to an inout parameter, to indi cate that i t can be modi fied by the function.
>N O T E
In-out parameters cannot have defaul t val ues,  and vari adi c parameters cannot be marked as i nout.  If you
mark a parameter as i nout,  i t cannot al so be marked as var or l et.

Here’s an example of a function cal led sw apT w oInts, whi ch has two in-out integer
parameters cal led a and b:
func sw apT w oInts(i nout a: Int,  i nout b: Int) {
l et temporaryA = a
a = b
b = temporaryA
}
The sw apT w oInts function simply swaps the value of b into a, and the value of a into b. The
function performs thi s swap by storing the value of a in a temporary constant cal led
temporaryA, assigning the value of b to a, and then assigning temporaryA to b.
You can cal l  the sw apT w oInts function wi th two variables of type Int to swap thei r values.
Note that the names of someInt and anotherInt are prefixed wi th an ampersand when they
are passed to the sw apT w oInts function:
var someInt = 3
var anotherInt = 107
sw apT w oInts(&someInt,  &anotherInt)
pri ntl n("someInt i s now  \(someInt),  and anotherInt i s now  \(anotherInt)")
// pri nts "someInt i s now  107,  and anotherInt i s now  3"
The example above shows that the original  values of someInt and anotherInt are modi fied by
the sw apT w oInts function, even though they were original ly defined outside of the function.
>N O T E
In-out parameters are not the same as returni ng a val ue from a functi on.  T he sw apT w oInts exampl e above
does not defi ne a return type or return a val ue,  but i t sti l l  modi fi es the val ues of someInt and anotherInt.  Inout parameters are an al ternati ve w ay for a functi on to have an effect outsi de of the scope of i ts functi on
body.

## Function Types
Every function has a speci fi c function type, made up of the parameter types and the
return type of the function.
For example:
func addT w oInts(a: Int,  b: Int) -> Int {
return a + b
}
func mul ti pl yT w oInts(a: Int,  b: Int) -> Int {
return a * b
}
Thi s example defines two simple mathemati cal  functions cal led addT w oInts and mul ti pl yT w oInts.
These functions each take two Int values, and return an Int value, whi ch i s the resul t of
performing an appropriate mathemati cal  operation.
The type of both of these functions i s (Int,  Int) -> Int. Thi s can be read as:
“A function type that has two parameters, both of type Int, and that returns a value of
type Int.”
Here’s another example, for a function wi th no parameters or return value:
func pri ntHel l oWorl d() {
pri ntl n("hel l o,  w orl d")
}
The type of thi s function i s () -> (), or “a function that has no parameters, and returns Voi d.”
Functions that don’t speci fy a return value always return Voi d, whi ch i s equivalent to an
empty tuple in Swi ft, shown as ().
## Using Function Types
You use function types just l ike any other types in Swi ft. For example, you can define a
constant or variable to be of a function type and assign an appropriate function to that
variable:
var mathFuncti on: (Int,  Int) -> Int = addT w oInts
Thi s can be read as:
“Define a variable cal led mathFuncti on, whi ch has a type of ‘a function that takes two Int
values, and returns an Int value.’ Set thi s new variable to refer to the function cal led
addT w oInts.”
The addT w oInts function has the same type as the mathFuncti on variable, and so thi s
assignment i s al lowed by Swi ft’s type-checker.
You can now cal l  the assigned function wi th the name mathFuncti on:
pri ntl n("Resul t: \(mathFuncti on(2,  3))")
// pri nts "Resul t: 5"
A di fferent function wi th the same matching type can be assigned to the same variable, in
the same way as for non-function types:
mathFuncti on = mul ti pl yT w oInts
pri ntl n("Resul t: \(mathFuncti on(2,  3))")
// pri nts "Resul t: 6"
As wi th any other type, you can leave i t to Swi ft to infer the function type when you
assign a function to a constant or variable:
l et anotherMathFuncti on = addT w oInts
// anotherMathFuncti on i s i nferred to be of type (Int,  Int) -> Int
## Function Types as Parameter Types
You can use a function type such as (Int,  Int) -> Int as a parameter type for another
function. Thi s enables you to leave some aspects of a function’s implementation for the
function’s cal ler to provide when the function i s cal led.
Here’s an example to print the resul ts of the math functions from above:
func pri ntMathResul t(mathFuncti on: (Int,  Int) -> Int,  a: Int,  b: Int) {
pri ntl n("Resul t: \(mathFuncti on(a,  b))")
}
pri ntMathResul t(addT w oInts,  3,  5)
// pri nts "Resul t: 8"
Thi s example defines a function cal led pri ntMathResul t, whi ch has three parameters. The fi rst
parameter i s cal led mathFuncti on, and i s of type (Int,  Int) -> Int. You can pass any function of
that type as the argument for thi s fi rst parameter. The second and thi rd parameters are
cal led a and b, and are both of type Int. These are used as the two input values for the
provided math function.
When pri ntMathResul t i s cal led, i t i s passed the addT w oInts function, and the integer values 3
and 5. It cal l s the provided function wi th the values 3 and 5, and prints the resul t of 8.
The role of pri ntMathResul t i s to print the resul t of a cal l  to a math function of an appropriate
type. It doesn’t matter what that function’s implementation actual ly does—i t matters only
that the function i s of the correct type. Thi s enables pri ntMathResul t to hand off some of i ts
functional i ty to the cal ler of the function in a type-safe way.
## Function Types as Return Types
You can use a function type as the return type of another function. You do thi s by wri ting
a complete function type immediately after the return arrow (->) of the returning function.
The next example defines two simple functions cal led stepForw ard and stepBackw ard. The
stepForw ard function returns a value one more than i ts input value, and the stepBackw ard
function returns a value one less than i ts input value. Both functions have a type of (Int) ->
Int:
func stepForw ard(i nput: Int) -> Int {
return i nput + 1
}
func stepBackw ard(i nput: Int) -> Int {
return i nput -  1
}
Here’s a function cal led chooseStepFuncti on, whose return type i s “a function of type (Int) -> Int”.
chooseStepFuncti on returns the stepForw ard function or the stepBackw ard function based on a
Boolean parameter cal led backw ards:
func chooseStepFuncti on(backw ards: Bool ) -> (Int) -> Int {
return backw ards ? stepBackw ard : stepForw ard
}
You can now use chooseStepFuncti on to obtain a function that wi l l  step in one di rection or the
other:
var currentVal ue = 3
l et moveNearerT oZero = chooseStepFuncti on(currentVal ue > 0)
// moveNearerT oZero now  refers to the stepBackw ard() functi on
The preceding example works out whether a posi tive or negative step i s needed to move
a variable cal led currentVal ue progressively closer to zero. currentVal ue has an ini tial  value of 3,
whi ch means that currentVal ue > 0 returns true, causing chooseStepFuncti on to return the
stepBackw ard function. A reference to the returned function i s stored in a constant cal led
moveNearerT oZero.
Now that moveNearerT oZero refers to the correct function, i t can be used to count to zero:
pri ntl n("Counti ng to zero:")
// Counti ng to zero:
w hi l e currentVal ue ! = 0 {
pri ntl n("\(currentVal ue). . .  ")
currentVal ue = moveNearerT oZero(currentVal ue)
}
pri ntl n("zero! ")
// 3. . .
// 2. . .
. .
ero!
## Nested Functions
Al l  of the functions you have encountered so far in thi s chapter have been examples of
global  functions, whi ch are defined at a global  scope. You can al so define functions inside
the bodies of other functions, known as nested functions.
Nested functions are hidden from the outside world by defaul t, but can sti l l  be cal led and
used by thei r enclosing function. An enclosing function can al so return one of i ts nested
functions to al low the nested function to be used in another scope.
You can rewri te the chooseStepFuncti on example above to use and return nested functions:
func chooseStepFuncti on(backw ards: Bool ) -> (Int) -> Int {
func stepForw ard(i nput: Int) -> Int { return i nput + 1 }
func stepBackw ard(i nput: Int) -> Int { return i nput -  1 }
return backw ards ? stepBackw ard : stepForw ard
}
var currentVal ue = -4
l et moveNearerT oZero = chooseStepFuncti on(currentVal ue > 0)
// moveNearerT oZero now  refers to the nested stepForw ard() functi on
w hi l e currentVal ue ! = 0 {
ri ntl n("\(currentVal ue). . .  ")
urrentVal ue = moveNearerT oZero(currentVal ue)
("zero! ")
. . .
. . .
. . .
. . .
ero!
