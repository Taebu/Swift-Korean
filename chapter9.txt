# 09 클로저 (Closures)
> Translator : inureyes (inureyes@gmail.com)

## 클로저 (Closures)
클로저는 사용자의 코드 안에서 전달되거나 사용할 수 있는 기능을 포함한 독립적인 블록(block)입니다. Swift에서의 클로저는 C 및 Objective-C 의 blocks와 유사하며, 다른 언어의 람다(lambda)와도 유사합니다.
클로저는 자신이 정의된 컨텍스트에서 임의의 상수 및 변수의 레퍼런스를 캡처하고 저장할 수 있습니다. 이러한 상수 및 변수를 제약하는 특징때문에 클로저라는 이름이 되었습니다. Swift는 모든 캡처된 메모리 관리를 제어합니다.

**노트**
"캡처하는" 개념에 대해서 익숙하지 않아도 걱정하지 마세요. 아래의 값 캡처하기 항목에서 자세히 다룰 것입니다.

함수 에서 소개된 전역 및 중첩 함수들은 사실 클로저의 특수한 경우들입니다. 클로저는 아래의 세가지 중 하나의 형태입니다.

- 전역 함수는 이름이 있지만 아무 값도 캡처하지 않는 클로저입니다.
- 중첩 함수들은 이름이 있고, 내부의 함수의 값을 캡처할 수 있는 클로저입니다.
- 클로저 표현식은 자신을 둘러싼 컨텍스트에서 값을 캡처할 수 있는 가벼운 문법으로 작성된 클로저입니다.

Swift의 클로저 표현식은 깨끗하고 명확한 스타일을 일반적인 경우에 대한 간략하고 명확한 구문을 최적화와 함께 제공합니다. 이러한 최적화는 아래의 항목을 포함합니다.

- 컨텍스트로부터 파라미터 및 리턴 값을 유추
- 단일 표현식 클로저로부터 명확한 리턴값
- 단축 매개변수명
- 클로저 문법 추적

## 클로저 표현식 (Closure expressions)
중첩 함수에서 소개된 중첩 함수들은 더 큰 함수의 일부로서 동작하는 자체 포함된 코드 블럭을 명명하거나 정의하는 편리한 방법입니다. 그러나, 종종 완전한 선언이나 이름이 없는 더 짧은 버전의 함수같은 구조를 만드는 것이 유용할 때가 있습니다. 이는 당신이 다른 함수들을 하나 또는 그 이상의 매개변수로 받는 함수를 만들때 특히 그렇습니다.

클로저 표현식들은 인라인 클로저를 간단명료하고 집중적인 문법으로 작성하는 방법입니다. 클로저 표현식은 명확성과 의도를 잃지 않는 선에서 가장 간결한 형태로 클로저를 작성하기 위한 몇가지 문법 최적화를 제공합니다. 아래의 클로저 표현식 예에서 sort 함수를 각 단계마다 동일한 기능을 표현하지만 더 간결해지도록 몇가지 단계를 거쳐 개량하는 최적화를 소개합니다.

## 정렬 함수
Swift 의 표준 라이브러리는 당신에 제공한 정렬 클로저(sorting closure)의 결과값에 기반하여 알려진 값들의 배열을 정렬하는 sort 라는 함수를 제공합니다. 정렬 과정이 끝나면, sort 함수는 원래와 동일한 타입(type) 및 크기를 갖지만 그 요소들은 올바르게 정렬된 새로운 배열을 리턴합니다.

아래의 클로저 표현식 예는 string 값으로 구성된 배열을 알파벳 역순으로 정렬합니다.

이 배열이 정렬될 배열입니다:

> let names = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]

sort 함수는 두 매개변수를 받습니다.

- 알려진 타입(type)의 값들로 된 배열
- 동일한 타입의 두 매개변수를 받아 첫번째 값이 두번째 값보다 앞에 나와야 할 지의 여부를 알려주는 Bool 값을 돌려주는 클로저. 정렬 클로저는 만약 첫 값이 두번째 값보다 앞에 나와야 할 경우 true를, 나머지 경우에는 false를 돌려줍니다.

이 예제는 String 값들의 배열을 정렬하므로, 정렬 클로저는 타입 (String, String) -> Bool 타입의 함수가 되어야 합니다.

정렬 클로저를 제공하는 한가지 방법은 정확한 타입과 함께 일반적인 함수를 작성하고, 이 함수를 sort 함수의 두번째 인자로 사용하는 방법입니다.

> func backwards(s1: String, s2: String) -> Bool {
> return s1 > s2
> }
> var reversed = sort(names, backwards)
> // reversed i s equal to ["Ewa", "Daniell a", "Chris", "Barry", "Alex"]

첫 번째 문자열 (S1)이 두 번째 문자열 (S2)보다 큰 경우, backwards 함수는 정렬된 배열에서 s1이 s2보다 먼저 나와야 함을 의미하는 true  를 돌려줍니다. string 안의 character들의 경우, "더 크다"는 의미는 "알파벳에서 나중에 등장하는" 것을 의미합니다. 이는 글자 "B"가 글자 "A"보다 "더 크다"는 의미이며, 문자열 "Tom" 이 문자열 "Tim" 보다 크다는 의미입니다. 따라서 이 함수는 "Barry"가 "Alex"보다 앞에 오게 되는 알파벳 역순 정렬 결과를 주게 됩니다. 

그러나, 이것은 본질적으로 하나의 표현 함수 (a > b) 인 기능을 작성하기엔 다소 장황한 방법입니다. 이 예제의 경우 클로저 표현식 문법을 사용하여 인라인 정렬 클로저를 작성하는 것이 더 바람직할 것입니다.

## 클로저 표현식 문법  (Closure Expression Syntax)
클로저 표현식 문법은 아래의 일반 형식을 따릅니다:

> { ( parameters ) -> return type in 
>   statements
> }

클로저 표현식 문법은  상수 매개변수, 변수 매개변수 및 inout 매개변수를 사용할 수 있습니다. 기본 값은 주어지지 않습니다. 만약 당신이 가변 매개 변수에 이름을 주고 마지막 매개 변수에 위치할 경우 가변 매개변수도 사용할 수 있습니다. 튜플 또한 매개변수 타입 및 리턴 타입으로 사용할 수 있습니다.

아래의 예는 앞에서 소개한 backwards 함수의 클로저 표현 판입니다.

> reversed = sort(names, { (s1: String, s2: String) -
>           > Bool in
> return s1 > s2
>  })

이 인라인 클로저에 대한 매개 변수의 및 리턴 타입의 정의는 backwards 함수의 정의와 동일합니다. 두 경우 모두, (s1: String, s2: String) -> Bool 로 쓸 수 있습니다. 그러나, 인라인 클로저 표현식의 경우, 매개변수와 리턴 타입은 중괄호 안에 쓰여야 하며, 밖에 쓰일 수는 없습니다.

클로저의 내용은 in 키워드로 시작합니다. 이 키워드는 클로저의 매개 변수 및 리턴 타입 정의가 끝났으며, 클로저의 내용이 시작됨을 지시합니다.

클로저의 내용이 매우 짧기 때문에, 심지어 한 줄에도 쓸 수 있습니다.

> reversed = sort(names, { (s1: String, s2: String) - > Bool in return s1 > s2 } )

이 구문은 sort 함수의 전체적인 호출이 똑같이 유지됨을 보여줍니다. 괄호쌍은 여전히 함수의 전체 매개 함수를 감싸고 있습니다. 그러나 그 중 하나의 매개변수는 이제 인라인 클로저입니다.


