# 09 클로저 (Closures)
> Translator : inureyes (inureyes@gmail.com)

## 클로저 (Closures)
클로저는 사용자의 코드 안에서 전달되거나 사용할 수 있는 기능을 포함한 독립적인 블록(block)입니다. Swift에서의 클로저는 C 및 Objective-C 의 blocks와 유사하며, 다른 언어의 람다(lambda)와도 유사합니다.
클로저는 자신이 정의된 컨텍스트 (context) 로부터 임의의 상수 및 변수의 레퍼런스를 획득 (capture)하고 저장할 수 있습니다. _(주: 클로저의 경우 클로저 바로 밖의 scope 의 상수 및 변수에 접근할 수 있다는 이야기입니다)_이렇게 상수 및 변수를 제약하는 특징때문에 클로저라는 이름이 되었습니다. Swift는 획득 과정의 메모리 관리를 모두 제어해줍니다.

**노트**
"획득" 개념에 대해서 익숙하지 않아도 걱정하지 마세요. 아래의 [값 획득하기]() 항목에서 자세히 다룰 것입니다.

함수 에서 소개된 전역 및 중첩 함수들은 사실 클로저의 특수한 경우들입니다. 클로저는 아래의 세가지 중 하나의 형태입니다.

- 전역 함수는 이름이 있지만 아무 값도 획득하지 않는 클로저입니다.
- 중첩 함수들은 이름이 있고, 내부의 함수의 값을 획득할 수 있는 클로저입니다.
- 클로저 표현식은 자신을 둘러싼 컨텍스트에서 값을 획득할 수 있는 가벼운 문법으로 작성된 클로저입니다.

Swift의 클로저 표현식은 깨끗하고 명확한 스타일을 일반적인 경우에 대한 간략하고 명확한 구문을 최적화와 함께 제공합니다. 이러한 최적화는 아래의 항목을 포함합니다.

- 컨텍스트로부터 인자 및 반환 값을 유추
- 단일 표현식 클로저로부터 명확한 반환값
- 단축 인자 이름
- 클로저 문법 추적

## 클로저 표현식 (Closure expressions)
중첩 함수에서 소개된 중첩 함수들은 더 큰 함수의 일부로서 동작하는 자체 포함된 코드 블럭을 명명하거나 정의하는 편리한 방법입니다. 그러나, 종종 완전한 선언이나 이름이 없는 더 짧은 버전의 함수같은 구조를 만드는 것이 유용할 때가 있습니다. 이는 당신이 다른 함수들을 하나 또는 그 이상의 인자로 받는 함수를 만들때 특히 그렇습니다.

클로저 표현식들은 인라인 클로저를 간단명료하고 집중적인 문법으로 작성하는 방법입니다. 클로저 표현식은 명확성과 의도를 잃지 않는 선에서 가장 간결한 형태로 클로저를 작성하기 위한 몇가지 문법 최적화를 제공합니다. 아래의 클로저 표현식 예에서 sort 함수를 각 단계마다 동일한 기능을 표현하지만 더 간결해지도록 몇가지 단계를 거쳐 개량하는 최적화를 소개합니다.

## 정렬 함수
Swift 의 표준 라이브러리는 당신에 제공한 정렬 클로저(sorting closure)의 결과값에 기반하여 알려진 값들의 배열을 정렬하는 sort 라는 함수를 제공합니다. 정렬 과정이 끝나면, sort 함수는 원래와 동일한 타입(type) 및 크기를 갖지만 그 요소들은 올바르게 정렬된 새로운 배열을 반환합니다.

아래의 클로저 표현식 예는 string 값으로 구성된 배열을 알파벳 역순으로 정렬합니다.

이 배열이 정렬될 배열입니다:

> let names = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]

sort 함수는 두 매개변수를 받습니다.

- 알려진 타입(type)의 값들로 된 배열
- 동일한 타입의 두 인자를 받아 첫번째 값이 두번째 값보다 앞에 나와야 할 지의 여부를 알려주는 Bool 값을 돌려주는 클로저. 정렬 클로저는 만약 첫 값이 두번째 값보다 앞에 나와야 할 경우 true를, 나머지 경우에는 false를 반환합니다.

이 예제는 String 값들의 배열을 정렬하므로, 정렬 클로저는 타입 (String, String) -> Bool 타입의 함수가 되어야 합니다.

정렬 클로저를 제공하는 한가지 방법은 정확한 타입과 함께 일반적인 함수를 작성하고, 이 함수를 sort 함수의 두번째 인자로 사용하는 방법입니다.

> func backwards(s1: String, s2: String) -> Bool {
> return s1 > s2
> }
> var reversed = sort(names, backwards)
> // reversed i s equal to ["Ewa", "Daniell a", "Chris", "Barry", "Alex"]

첫 번째 문자열 (S1)이 두 번째 문자열 (S2)보다 큰 경우, backwards 함수는 정렬된 배열에서 s1이 s2보다 먼저 나와야 함을 의미하는 true  를 반환합니다. string 안의 character들의 경우, "더 크다"는 의미는 "알파벳에서 나중에 등장하는" 것을 의미합니다. 이는 글자 "B"가 글자 "A"보다 "더 크다"는 의미이며, 문자열 "Tom" 이 문자열 "Tim" 보다 크다는 의미입니다. 따라서 이 함수는 "Barry"가 "Alex"보다 앞에 오게 되는 알파벳 역순 정렬 결과를 주게 됩니다. 

그러나, 이것은 본질적으로 하나의 표현 함수 (a > b) 인 기능을 작성하기엔 다소 장황한 방법입니다. 이 예제의 경우 클로저 표현식 문법을 사용하여 인라인 정렬 클로저를 작성하는 것이 더 바람직할 것입니다.

## 클로저 표현식 문법  (Closure Expression Syntax)
클로저 표현식 문법은 아래의 일반 형식을 따릅니다:

> { ( parameters ) -> return type in 
>   statements
> }

클로저 표현식 문법은  상수 인자, 변수 인자 및 inout 인자를 사용할 수 있습니다. 기본 값은 주어지지 않습니다. 만약 당신이 가변 인자에 이름을 주고 마지막 매개 변수에 위치할 경우 가변 인자도 사용할 수 있습니다. 튜플 또한 인자 타입 및 반환 타입으로 사용할 수 있습니다.

아래의 예는 앞에서 소개한 backwards 함수의 클로저 표현 판입니다.

> reversed = sort(names, { (s1: String, s2: String) -
>           > Bool in
> return s1 > s2
>  })

이 인라인 클로저에 대한 인자의 및 리턴 타입의 정의는 backwards 함수의 정의와 동일합니다. 두 경우 모두, (s1: String, s2: String) -> Bool 로 쓸 수 있습니다. 그러나, 인라인 클로저 표현식의 경우, 인자와 리턴 타입은 중괄호 안에 쓰여야 하며, 밖에 쓰일 수는 없습니다.

클로저의 내용은 in 키워드로 시작합니다. 이 키워드는 클로저의 인자 및 반환 타입 정의가 끝났으며, 클로저의 내용이 시작됨을 지시합니다.

클로저의 내용이 매우 짧기 때문에, 심지어 한 줄에도 쓸 수 있습니다.

> reversed = sort(names, { (s1: String, s2: String) - > Bool in return s1 > s2 } )

이 구문은 sort 함수의 전체적인 호출이 똑같이 유지됨을 보여줍니다. 괄호쌍은 여전히 함수의 전체 인자를 감싸고 있습니다. 그러나 그 중 하나의 인자는 이제 인라인 클로저입니다.

## 컨텍스트로부터 타입 유추하기 (Inferring Type From Context)

정렬 클로저가 함수의 인자로 전달되기 때문에, Swift는 클로저의 인자 타입과 soft 함수의 두번째 인자의 타입으로부터 반환되는 값의 타입을 유추할 수 있씁니다. 이 인자는 (String, String) -> Bool 타입의 함수를 기대합니다. 이는 String, String 및 Bool 타입이 클로저 표현형의 정의의 일부로 쓰일 필요가 없음을 의미합니다. 모든 타입이 유추 가능하기 때문에, 반환 화살표 (->) 와 인자 이름을 감싼 괄호 또한 제외할 수 있습니다.

> reversed = sort(names, { s1, s2 in return s1 > s2 } )

인라인 클로저 표현 형태로 클로저를 함수에 전달할 경우 인자와 반환 값의 타입을 유추하는 것이 언제나 가능합니다. 결과적으로, 인라인 클로저를 최대한의 형태로 명시적으로 기술할 일은 거의 없을 것입니다.

그럼에도 불구하고, 당신이 필요로 하거나, 또한 코드를 읽는 사람들에게 모호함을 주고 싶지 않을 경우 타입을 명시적으로 기술할 수 있습니다. sort 함수의 경우, 클로저의 목적은 정렬이 일어난다는 사실로부터 명확하게 보이며, 독자들은 문자열들의 배열을 정렬하는 것을 돕기 떄문에 이 클로저가 String 값과 함꼐 돌아간다고 가정하는 것이 안전합니다. 

## 단일 표현식 클로저로부터의 암시적 반환 ( Implicit Returns from Single-Expression Closures)

단일 표현식 클로저는 앞의 예에서 정의할 때 return 키워드를 생략하여 단일 표현식의 결과를 암시적으로 반환할 수 있습니다. 

> reversed = sort(names, { s1, s2 in s1 > s2 } )

sort 함수의 두번째 인자의 함수 형은 클로저가 Bool 값을 반드시 반환해야 함을 명확하게 해 줍니다. 클로저의 내용이 Bool 값을 반환하는 단일 표현식 (s1 > s2) 이기 때문에, 이 경우 애매모호함이 발생하지 않으며, return 키워드는 생략이 가능합니다.

## 단축 인자 이름들 ( Shorthand Argument Names)
Swift는 자동으로 단축 인자 이름을 인라인 클로저에 제공하며, 클로저의 인자들을 $0, $1, $2 등등의 방식으로 참조할 수 있습니다. 

만약 이러한 단축 인자 이름들을 클로저 표현식에서 사용할 경우, 클로저 인자 리스트를 클로저의 정의에서 생략할 수 있으며, 단축 인자들의 번호 및 타입은 기대되는 함수 타입으로부터 추정될 것입니다. 클로저 표현식이 클로저 내용에 완전히 표현될 수 있으므로 in 키워드 또한 생략할 수 있습니다:

> reversed = sort(names, { $0 > $1 } )

여기서 $0 와 $1 은 클로저의 첫번째와 두번째 String 매개변수를 가리킵니다.

## 연산자 함수들 ( Operator Functions )
사실 위의 클로저 표현식은 _더 짧아질 수도_ 있습니다. Swift 의 String 타입은 String에 특화된 크기 비교 연산자 (>) 를 두 String 인자를 갖는 함수로 정의하고 있으며, Bool 타입을 반환합니다. 이 연산자는 sort 함수의 두번째 인자를 위해 필요한 함수형과 정확히 칠치합니다. 그러므로, 이 크기 비교 연산자를 바로 전달하면 Swift 는 사용자가 String 전용의 구현체를 사용하려고 한다고 유추합니다.

> reversed = sort(names, > )

연산자 함수에 대해 더 많은 내용은 [연산자 함수]() 항목을 참조하시기 바랍니다.

## 후행 클로저 ( Trailing Closures )

만약 클로저 표현식을 함수에 함수의 마지막 인자로 전달할 때 클로저 표현식이 긴 경우, 대신에 후행 클로저 (Trailing closure) 를 작성하는 것이 유용할 수 있습니다. 후행 클로저는 함수 호출 괄호의 밖 (또는 뒤) 에 쓰여져서 함수를 지원하는 클로저 표현식입니다.

> func someFunctionThatTakesAClosure(closure: () -> ()) {
>     // function body goes here
> }
> 
> // here's how you call this function without using a trailing closure:
> 
> someFunctionThatTakesAClosure({
>     // closure's body goes here
>     })
>  
> // here's how you call this function with a trailing closure instead:
>  
> someFunctionThatTakesAClosure() {
>     // trailing closure's body goes here
> }

