# 12 속성

Properties
Properties associate values wi th a parti cular class, structure, or enumeration. Stored
properties store constant and variable values as part of an instance, whereas computed
properties cal culate (rather than store) a value. Computed properties are provided by
classes, structures, and enumerations. Stored properties are provided only by classes and
structures.
Stored and computed properties are usual ly associated wi th instances of a parti cular
type. However, properties can al so be associated wi th the type i tsel f. Such properties are
known as type properties.
In addi tion, you can define property observers to moni tor changes in a property’s value,
whi ch you can respond to wi th custom actions. Property observers can be added to stored
properties you define yoursel f, and al so to properties that a subclass inheri ts from i ts
superclass.
Stored Properties
In i ts simplest form, a stored property i s a constant or variable that i s stored as part of an
instance of a parti cular class or structure. Stored properties can be ei ther variable stored
properties (introduced by the var keyword) or constant stored properties (introduced by
the l et keyword).
You can provide a defaul t value for a stored property as part of i ts defini tion, as described
in Defaul t Property Values. You can al so set and modi fy the ini tial  value for a stored
property during ini tial i zation. Thi s i s true even for constant stored properties, as
described in Modi fying Constant Properties During Ini tial i zation.
The example below defines a structure cal led Fi xedLengthRange, whi ch describes a range of
integers whose range length cannot be changed once i t i s created:
struct Fi xedLengthRange {
var fi rstVal ue: Int
l et l ength: Int
}
var rangeOfT hreeItems = Fi xedLengthRange(fi rstVal ue: 0,  l ength: 3)
// the range represents i nteger val ues 0,  1,  and 2
rangeOfT hreeItems. fi rstVal ue = 6
// the range now  represents i nteger val ues 6,  7,  and 8
Instances of Fi xedLengthRange have a variable stored property cal led fi rstVal ue and a constant
stored property cal led l ength. In the example above, l ength i s ini tial i zed when the new range
i s created and cannot be changed thereafter, because i t i s a constant property.
Stored Properties of Constant Structure Instances
If you create an instance of a structure and assign that instance to a constant, you cannot
modi fy the instance’s properties, even i f they were declared as variable properties:
l et rangeOfFourItems = Fi xedLengthRange(fi rstVal ue: 0,  l ength: 4)
// thi s range represents i nteger val ues 0,  1,  2,  and 3
rangeOfFourItems. fi rstVal ue = 6
// thi s w i l l  report an error,  even thought fi rstVal ue i s a vari abl e property
Because rangeOfFourItems i s declared as a constant (wi th the l et keyword), i t i s not possible
to change i ts fi rstVal ue property, even though fi rstVal ue i s a variable property.
Thi s behavior i s due to structures being value types. When an instance of a value type i s
marked as a constant, so are al l  of i ts properties.
The same i s not true for classes, whi ch are reference types. If you assign an instance of a
reference type to a constant, you can sti l l  change that instance’s variable properties.
Lazy Stored Properties
A lazy stored property i s a property whose ini tial  value i s not cal culated unti l  the fi rst time
i t i s used. You indi cate a lazy stored property by wri ting the @l azy attribute before i ts
declaration.
N O T E
Y ou must al w ays decl are a l azy property as a vari abl e (w i th the var keyw ord),  because i ts i ni ti al  val ue may not
be retri eved unti l  after i nstance i ni ti al i zati on compl etes.  Constant properti es must al w ays have a val ue before
i ni ti al i zati on compl etes,  and therefore cannot be decl ared as l azy.
Lazy properties are useful  when the ini tial  value for a property i s dependent on outside
factors whose values are not known unti l  after an instance’s ini tial i zation i s complete.
Lazy properties are al so useful  when the ini tial  value for a property requi res complex or
computational ly expensive setup that should not be performed unless or unti l  i t i s
needed.
The example below uses a lazy stored property to avoid unnecessary ini tial i zation of a
complex class. Thi s example defines two classes cal led DataImporter and DataManager, nei ther
of whi ch i s shown in ful l :
cl ass DataImporter {
/*
DataImporter i s a cl ass to i mport data from an external  fi l e.
T he cl ass i s assumed to take a non- tri vi al  amount of ti me to i ni ti al i ze.
*/
var fi l eName = "data. txt"
// the DataImporter cl ass w oul d provi de data i mporti ng functi onal i ty here
}
DataManager {
@l azy var i mporter = DataImporter()
ar data = Stri ng[]()
/ the DataManager cl ass w oul d provi de data management functi onal i ty here
manager = DataManager()
ager. data += "Some data"
ager. data += "Some more data"
e DataImporter i nstance for the i mporter property has not yet been created
The DataManager class has a stored property cal led data, whi ch i s ini tial i zed wi th a new,
empty array of Stri ng values. Al though the rest of i ts functional i ty i s not shown, the purpose
of thi s DataManager class i s to manage and provide access to thi s array of Stri ng data.
Part of the functional i ty of the DataManager class i s the abi l i ty to import data from a fi le.
Thi s functional i ty i s provided by the DataImporter class, whi ch i s assumed to take a non-
trivial  amount of time to ini tial i ze. Thi s might be because a DataImporter instance needs to
open a fi le and read i ts contents into memory when the DataImporter instance i s ini tial i zed.
It i s possible for a DataManager instance to manage i ts data wi thout ever importing data
from a fi le, so there i s no need to create a new DataImporter instance when the DataManager
i tsel f i s created. Instead, i t makes more sense to create the DataImporter instance i f and
when i t i s fi rst used.
Because i t i s marked wi th the @l azy attribute, the DataImporter instance for the i mporter
property i s only created when the i mporter property i s fi rst accessed, such as when i ts
fi l eName property i s queried:
pri ntl n(manager. i mporter. fi l eName)
// the DataImporter i nstance for the i mporter property has now  been created
// pri nts "data. txt"
Stored Properties and Instance Variables
If you have experience wi th Objective-C, you may know that i t provides two ways to store
values and references as part of a class instance. In addi tion to properties, you can use
instance variables as a backing store for the values stored in a property.
Swi ft uni fies these concepts into a single property declaration. A Swi ft property does not
have a corresponding instance variable, and the backing store for a property i s not
accessed di rectly. Thi s approach avoids confusion about how the value i s accessed in
di fferent contexts and simpl i fies the property’s declaration into a single, defini tive
statement. Al l  information about the property—including i ts name, type, and memory
management characteri sti cs—i s defined in a single location as part of the type’s
defini tion.
Computed Properties
In addi tion to stored properties, classes, structures, and enumerations can define
computed properties, whi ch do not actual ly store a value. Instead, they provide a getter
and an optional  setter to retrieve and set other properties and values indi rectly.
struct Poi nt {
var x = 0. 0,  y = 0. 0
}
struct Si ze {
var w i dth = 0. 0,  hei ght = 0. 0
}
struct Rect {
var ori gi n = Poi nt()
var si ze = Si ze()
ar center: Poi nt {
et {
l et centerX = ori gi n. x + (si ze.w i dth / 2)
l et centerY  = ori gi n. y + (si ze. hei ght / 2)
return Poi nt(x: centerX,  y: centerY )
et(new Center) {
ori gi n. x = new Center. x -  (si ze.w i dth / 2)
ori gi n. y = new Center. y -  (si ze. hei ght / 2)
square = Rect(ori gi n: Poi nt(x: 0. 0,  y: 0. 0),
ze: Si ze(w i dth: 10. 0,  hei ght: 10. 0))
i ti al SquareCenter = square. center
re. center = Poi nt(x: 15. 0,  y: 15. 0)
("square. ori gi n i s now  at (\(square. ori gi n. x),  \(square. ori gi n. y))")
i nts "square. ori gi n i s now  at (10. 0,  10. 0)"
Thi s example defines three structures for working wi th geometri c shapes:
The Rect structure al so provides a computed property cal led center. The current center
Poi nt encapsulates an (x,  y) coordinate.
Si ze encapsulates a w i dth and a hei ght.
Rect defines a rectangle by an origin point and a si ze.
posi tion of a Rect can always be determined from i ts ori gi n and si ze, and so you don’t need to
store the center point as an expl i ci t Poi nt value. Instead, Rect defines a custom getter and
setter for a computed variable cal led center, to enable you to work wi th the rectangle’s
center as i f i t were a real  stored property.
The preceding example creates a new Rect variable cal led square. The square variable i s
ini tial i zed wi th an origin point of (0,  0), and a width and height of 10. Thi s square i s
represented by the blue square in the diagram below.
The square variable’s center property i s then accessed through dot syntax (square. center), whi ch
causes the getter for center to be cal led, to retrieve the current property value. Rather than
returning an exi sting value, the getter actual ly cal culates and returns a new Poi nt to
represent the center of the square. As can be seen above, the getter correctly returns a
center point of (5,  5).
The center property i s then set to a new value of (15,  15), whi ch moves the square up and to
the right, to the new posi tion shown by the orange square in the diagram below. Setting
the center property cal l s the setter for center, whi ch modi fies the x and y values of the stored
ori gi n property, and moves the square to i ts new posi tion.
Shorthand Setter Declaration
If a computed property’s setter does not define a name for the new value to be set, a
defaul t name of new Val ue i s used. Here’s an al ternative version of the Rect structure, whi ch
takes advantage of thi s shorthand notation:
struct Al ternati veRect {
var ori gi n = Poi nt()
var si ze = Si ze()
var center: Poi nt {
get {
l et centerX = ori gi n. x + (si ze.w i dth / 2)
l et centerY  = ori gi n. y + (si ze. hei ght / 2)
return Poi nt(x: centerX,  y: centerY )
}
et {
ori gi n. x = new Val ue. x -  (si ze.w i dth / 2)
ori gi n. y = new Val ue. y -  (si ze. hei ght / 2)
Read-Only Computed Properties
A computed property wi th a getter but no setter i s known as a read-only computed
property. A read-only computed property always returns a value, and can be accessed
through dot syntax, but cannot be set to a di fferent value.
N O T E
Y ou must decl are computed properti es—i ncl udi ng read-onl y computed properti es—as vari abl e properti es w i th
the var keyw ord,  because thei r val ue i s not fi xed.  T he l et keyw ord i s onl y used for constant properti es,  to
i ndi cate that thei r val ues cannot be changed once they are set as part of i nstance i ni ti al i zati on.
You can simpl i fy the declaration of a read-only computed property by removing the get
keyword and i ts braces:
struct Cuboi d {
var w i dth = 0. 0,  hei ght = 0. 0,  depth = 0. 0
var vol ume: Doubl e {
return w i dth * hei ght * depth
}
}
l et fourByFi veByT w o = Cuboi d(w i dth: 4. 0,  hei ght: 5. 0,  depth: 2. 0)
pri ntl n("the vol ume of fourByFi veByT w o i s \(fourByFi veByT w o. vol ume)")
// pri nts "the vol ume of fourByFi veByT w o i s 40. 0"
Thi s example defines a new structure cal led Cuboi d, whi ch represents a 3D rectangular box
wi th w i dth, hei ght, and depth properties. Thi s structure al so has a read-only computed
property cal led vol ume, whi ch cal culates and returns the current volume of the cuboid. It
doesn’t make sense for vol ume to be settable, because i t would be ambiguous as to whi ch
values of w i dth, hei ght, and depth should be used for a parti cular vol ume value. Nonetheless, i t
i s useful  for a Cuboi d to provide a read-only computed property to enable external  users to
di scover i ts current cal culated volume.
Property Observers
Property observers observe and respond to changes in a property’s value. Property
observers are cal led every time a property’s value i s set, even i f the new value i s the
same as the property’s current value.
You can add property observers to any stored properties you define, apart from lazy
stored properties. You can al so add property observers to any inheri ted property
(whether stored or computed) by overriding the property wi thin a subclass. Property
overriding i s described in Overriding.
N O T E
Y ou don’t need to defi ne property observers for non-overri dden computed properti es,  because you can
observe and respond to changes to thei r val ue from di rectl y w i thi n the computed property’s setter.
You have the option to define ei ther or both of these observers on a property:
w i l l Set i s cal led just before the value i s stored.
di dSet i s cal led immediately after the new value i s stored.
If you implement a w i l l Set observer, i t i s passed the new property value as a constant
parameter. You can speci fy a name for thi s parameter as part of your w i l l Set
implementation. If you choose not to wri te the parameter name and parentheses wi thin
your implementation, the parameter wi l l  sti l l  be made avai lable wi th a defaul t parameter
name of new Val ue.
Simi larly, i f you implement a di dSet observer, i t wi l l  be passed a constant parameter
containing the old property value. You can name the parameter i f you wi sh, or use the
defaul t parameter name of ol dVal ue.
N O T E
w i l l Set and di dSet observers are not cal l ed w hen a property i s fi rst i ni ti al i zed.  T hey are onl y cal l ed w hen the
property’s val ue i s set outsi de of an i ni ti al i zati on context.
Here’s an example of w i l l Set and di dSet in action. The example below defines a new class
cal led StepCounter, whi ch tracks the total  number of steps that a person takes whi le
walking. Thi s class might be used wi th input data from a pedometer or other step counter
to keep track of a person’s exerci se during thei r dai ly routine.
cl ass StepCounter {
var total Steps: Int = 0 {
w i l l Set(new T otal Steps) {
pri ntl n("About to set total Steps to \(new T otal Steps)")
}
di dSet {
i f total Steps > ol dVal ue  {
pri ntl n("Added \(total Steps -  ol dVal ue) steps")
}
tepCounter = StepCounter()
Counter. total Steps = 200
bout to set total Steps to 200
dded 200 steps
Counter. total Steps = 360
bout to set total Steps to 360
dded 160 steps
Counter. total Steps = 896
bout to set total Steps to 896
dded 536 steps
The StepCounter class declares a total Steps property of type Int. Thi s i s a stored property wi th
w i l l Set and di dSet observers.
The w i l l Set and di dSet observers for total Steps are cal led whenever the property i s assigned a
new value. Thi s i s true even i f the new value i s the same as the current value.
Thi s example’s w i l l Set observer uses a custom parameter name of new T otal Steps for the
upcoming new value. In thi s example, i t simply prints out the value that i s about to be
set.
The di dSet observer i s cal led after the value of total Steps i s updated. It compares the new
value of total Steps against the old value. If the total  number of steps has increased, a
message i s printed to indi cate how many new steps have been taken. The di dSet observer
does not provide a custom parameter name for the old value, and the defaul t name of
ol dVal ue i s used instead.
N O T E
If you assi gn a val ue to a property w i thi n i ts ow n di dSet observer,  the new  val ue that you assi gn w i l l  repl ace
the one that w as just set.
Global and Local Variables
The capabi l i ties described above for computing and observing properties are al so
avai lable to global  variables and local  variables. Global  variables are variables that are
defined outside of any function, method, closure, or type context. Local  variables are
variables that are defined wi thin a function, method, or closure context.
The global  and local  variables you have encountered in previous chapters have al l  been
stored variables. Stored variables, l ike stored properties, provide storage for a value of a
certain type and al low that value to be set and retrieved.
However, you can al so define computed variables and define observers for stored
variables, in ei ther a global  or local  scope. Computed variables cal culate rather than store
a value, and are wri tten in the same way as computed properties.
N O T E
Gl obal  constants and vari abl es are al w ays computed l azi l y,  i n a si mi l ar manner to Lazy Stored Properti es.  Unl i ke
l azy stored properti es,  gl obal  constants and vari abl es do not need to be marked w i th the @l azy attri bute.
Local  constants and vari abl es are never computed l azi l y.
Type Properties
Instance properties are properties that belong to an instance of a parti cular type. Every
time you create a new instance of that type, i t has i ts own set of property values,
separate from any other instance.
You can al so define properties that belong to the type i tsel f, not to any one instance of
that type. There wi l l  only ever be one copy of these properties, no matter how many
instances of that type you create. These kinds of properties are cal led type properties.
Type properties are useful  for defining values that are universal  to al l  instances of a
parti cular type, such as a constant property that al l  instances can use (l ike a stati c
constant in C), or a variable property that stores a value that i s global  to al l  instances of
that type (l ike a stati c variable in C).
For value types (that i s, structures and enumerations), you can define stored and
computed type properties. For classes, you can define computed type properties only.
Stored type properties for value types can be variables or constants. Computed type
properties are always declared as variable properties, in the same way as computed
instance properties.
N O T E
Unl i ke stored i nstance properti es,  you must al w ays gi ve stored type properti es a defaul t val ue.  T hi s i s because
the type i tsel f does not have an i ni ti al i zer that can assi gn a val ue to a stored type property at i ni ti al i zati on ti me.
Type Property Syntax
In C and Objective-C, you define stati c constants and variables associated wi th a type as
global  stati c variables. In Swi ft, however, type properties are wri tten as part of the type’s
defini tion, wi thin the type’s outer curly braces, and each type property i s expl i ci tly scoped
to the type i t supports.
You define type properties for value types wi th the stati c keyword, and type properties for
class types wi th the cl ass keyword. The example below shows the syntax for stored and
computed type properties:
struct SomeStructure {
stati c var storedT ypeProperty = "Some val ue. "
stati c var computedT ypeProperty: Int {
// return an Int val ue here
}
}
enum SomeEnumerati on {
stati c var storedT ypeProperty = "Some val ue. "
stati c var computedT ypeProperty: Int {
/ return an Int val ue here
SomeCl ass {
ass var computedT ypeProperty: Int {
/ return an Int val ue here
N O T E
T he computed type property exampl es above are for read-onl y computed type properti es,  but you can al so
defi ne read-w ri te computed type properti es w i th the same syntax as for computed i nstance properti es.
Querying and Setting Type Properties
Type properties are queried and set wi th dot syntax, just l ike instance properties.
However, type properties are queried and set on the type, not on an instance of that
type. For example:
pri ntl n(SomeCl ass. computedT ypeProperty)
// pri nts "42"
pri ntl n(SomeStructure. storedT ypeProperty)
// pri nts "Some val ue. "
SomeStructure. storedT ypeProperty = "Another val ue. "
pri ntl n(SomeStructure. storedT ypeProperty)
// pri nts "Another val ue. "
The examples that fol low use two stored type properties as part of a structure that
model s an audio level  meter for a number of audio channel s. Each channel  has an integer
audio level  between 0 and 10 inclusive.
The figure below i l lustrates how two of these audio channel s can be combined to model  a
stereo audio level  meter. When a channel ’s audio level  i s 0, none of the l ights for that
channel  are l i t. When the audio level  i s 10, al l  of the l ights for that channel  are l i t. In thi s
figure, the left channel  has a current level  of 9, and the right channel  has a current level
of 7:
The audio channel s described above are represented by instances of the Audi oChannel
structure:
struct Audi oChannel  {
stati c l et threshol dLevel  = 10
stati c var maxInputLevel ForAl l Channel s = 0
var currentLevel : Int = 0 {
di dSet {
i f currentLevel  > Audi oChannel . threshol dLevel  {
// cap the new  audi o l evel  to the threshol d l evel
currentLevel  = Audi oChannel . threshol dLevel
}
i f currentLevel  > Audi oChannel .maxInputLevel ForAl l Channel s {
// store thi s as the new  overal l  maxi mum i nput l evel
Audi oChannel .maxInputLevel ForAl l Channel s = currentLevel
}
The Audi oChannel  structure defines two stored type properties to support i ts functional i ty.
The fi rst, threshol dLevel , defines the maximum threshold value an audio level  can take. Thi s
i s a constant value of 10 for al l  Audi oChannel  instances. If an audio signal  comes in wi th a
higher value than 10, i t wi l l  be capped to thi s threshold value (as described below).
The second type property i s a variable stored property cal led maxInputLevel ForAl l Channel s. Thi s
keeps track of the maximum input value that has been received by any Audi oChannel
instance. It starts wi th an ini tial  value of 0.
The Audi oChannel  structure al so defines a stored instance property cal led currentLevel , whi ch
represents the channel ’s current audio level  on a scale of 0 to 10.
The currentLevel  property has a di dSet property observer to check the value of currentLevel
whenever i t i s set. Thi s observer performs two checks:
If the new value of currentLevel  i s greater than the al lowed threshol dLevel , the property
observer caps currentLevel  to threshol dLevel .
If the new value of currentLevel  (after any capping) i s higher than any value
N O T E
In the fi rst of these tw o checks,  the di dSet observer sets currentLevel  to a di fferent val ue.  T hi s does not,
how ever,  cause the observer to be cal l ed agai n.
You can use the Audi oChannel  structure to create two new audio channel s cal led l eftChannel  and
ri ghtChannel , to represent the audio level s of a stereo sound system:
var l eftChannel  = Audi oChannel ()
var ri ghtChannel  = Audi oChannel ()
If you set the currentLevel  of the left channel  to 7, you can see that the maxInputLevel ForAl l Channel s
type property i s updated to equal  7:
l eftChannel . currentLevel  = 7
pri ntl n(l eftChannel . currentLevel )
// pri nts "7"
pri ntl n(Audi oChannel .maxInputLevel ForAl l Channel s)
// pri nts "7"
If you try to set the currentLevel  of the right channel  to 11, you can see that the right
channel ’s currentLevel  property i s capped to the maximum value of 10, and the
maxInputLevel ForAl l Channel s type property i s updated to equal  10:
ri ghtChannel . currentLevel  = 11
pri ntl n(ri ghtChannel . currentLevel )
// pri nts "10"
pri ntl n(Audi oChannel .maxInputLevel ForAl l Channel s)
// pri nts "10"
