## 12 속성 (Properties)
> Translator : mango (minkyu.shim@gmail.com)

Properties associate values with a particular class, structure, or enumeration. Stored
properties store constant and variable values as part of an instance, whereas computed
properties calculate (rather than store) a value. Computed properties are provided by
classes, structures, and enumerations. Stored properties are provided only by classes and
structures.

속성은 특정 클래스, 구조체(structure), 혹은 열거형(Enumeration)과 값들을 연결해준다. 
저장속성(Stored property)는 상수나 변수 값을 인스턴스의 일부로 저장한다.
계산속성(Computed property)는 값을 그냥 저장하는 것이 아니라 계산한다. 
계산속성은 클래스나 구조체 그리고 열거형에 의해 제공된다. 
저장속성는 클래스와 구조체에 의해서만 제공된다.

Stored and computed properties are usually associated with instances of a particular
type. However, properties can also be associated with the type itself. Such properties are
known as type properties.

저장속성과 계산속성은 일반적으로 특정 타입의 인스턴스와 연결된다. 하지만, 속성은 타입 자체와 연결될수도 있는데, 이런 속성을 타입 속성(type property)라고 한다.

In addition, you can define property observers to monitor changes in a property’s value,
which you can respond to with custom actions. Property observers can be added to stored
properties you define yourself, and also to properties that a subclass inherits from i ts
superclass.

덧붙여, 프로그래머는 속성값의 변경을 모니터링하기 위해 속성 관찰/감시자(property observer)를 정의할 수 있다. 이것은 프로그래머가 속성값의 변경에 직접 정의한 동작들로 대응할 수 있게 해준다. 속성감시자/관찰자는 프로그래머가 직접 정의한 저장속성이나 부모클래스에서 상속받은 속성들에 추가할 수 있다.

# 저장속성 (Stored Property)

In its simplest form, a stored property is a constant or variable that is stored as part of an
instance of a particular class or structure. Stored properties can be either variable stored
properties (introduced by the var keyword) or constant stored properties (introduced by
the let keyword).

저장 속성은 가장 단순한 형태일때 특정 클래스와 구조체의 인스턴스에 저장되는 상수나 변수다. var 키워드로 선언(introduced)되면, 변수저장속성(variable stored property). let 키워드로 선언되면 상수저장속성(constant stored property)이라 한다.

You can provide a default value for a stored property as part of its definition, as described
in Default Property Values. You can also set and modify the initial value for a stored
property during initialization. This is true even for constant stored properties, as
described in Modifying Constant Properties During Initialization.

프로그래머는 저장 속성을 정의할 때 초기값을 지정할 수 있다. 이에 대해서는 "초기속성값" 챕터에서 설명되어있다. 저장된 속성의 초기값을 수정할 수도 있는데, 심지어 상수 저장속성마저도 수정이 가능하다. 이에 대해서는 "초기화시 상수속성수정/변경하기" 챕터에 설명되어있다.

The example below defines a structure called FixedLengthRange, whi ch describes a range of
integers whose range length cannot be changed once i t i s created:

아래 예제는 FixedLengthRange라는 구조체를 정의한다. 이 구조체는 특정 범위의 정수들을 의미하는데, 이 범위는 한번 생성되면 수정되지 않는다.

```
struct FixedLengthRange {
    var firstValue: Int
    let length: Int
}

var rangeOfT hreeItems = FixedLengthRange(firstValue: 0,  length: 3)

// the range represents integer values 0,  1,  and 2
// 이 구조체의 범위는 0, 1, 2 이다.

rangeOfThreeItems.firstValue = 6

// the range now  represents integer val ues 6,  7,  and 8
// 구조체의 범위는 이제 6, 7, 8 이다.
```

Instances of FixedLengthRange have a variable stored property called firstValue and a constant
stored property called l ength. In the example above, l ength i s ini tial i zed when the new range
i s created and cannot be changed thereafter, because i t i s a constant property.

FixedLengthRange 구조체의 인스턴스들은 변수저장속성 firstValue와 상수저장속성 length를 갖는다. 위의 예제에서는 length 속성은 상수속성이기 때문에 구조체가 생성될때 최초로 지정되고, 이후로는 변경되지 않는다. 

# Stored Properties of Constant Structure Instances
# 상수 구조체 인스턴스의 저장속성

If you create an instance of a structure and assign that instance to a constant, you cannot
modify the instance’s properties, even if they were declared as variable properties:

상수로 선언된 구조체 인스턴스의 속성들은 변수속성이더라도 수정되지 않는다. 

```swift
let rangeOfFourItems = FixedLengthRange(firstVal ue: 0,  length: 4)
// 이 구조체의 범위는 0, 1, 2, 3 이다.
rangeOfFourItems.firstValue = 6
// firstValue는 변수속성이지만 여기서 에러가 난다. 
```
Because rangeOfFourItems is declared as a constant (with the let keyword), it is not possible
to change its firstValue property, even though firstVal ue i s a variable property.
Thi s behavior i s due to structures being value types. When an instance of a value type i s
marked as a constant, so are al l  of i ts properties.
The same i s not true for classes, whi ch are reference types. If you assign an instance of a
reference type to a constant, you can sti l l  change that instance’s variable properties.

rangeOfFourItems 인스턴스는 let 키워드를 통해 상수로 선언되었으므로 그 속성인 firstValue는 비록 변수속성이더라도  수정할 수 없다.
이러한 동작은 구조체가 값타입(value type)이기 때문인데, 값타입의 인스턴스가 상수로 선언되면 그 속성들도 모두 상수가 된다.
이와 비교해서, 참조타입(reference type)인 클래스는 다르게 동작한다. 참조타입의 인스턴스를 상수로 선언하더라고 그 변수 속성들은 여전히 수정이 가능하다.

# 게으른 저장속성(Lazy Stored Property)

A lazy stored property i s a property whose ini tial  value i s not cal culated unti l  the fi rst time
i t i s used. You indi cate a lazy stored property by wri ting the @l azy attribute before i ts
declaration.

게으른 저장속성은 그 초기값이 최초로 사용되기전까지는 계산되지 않는다. 프로그래머는 선언시에 @lazy attribute라고 써줌으로써 게으른 저장속성을 표시할 수 있다. 

N O T E

Y ou must al w ays decl are a l azy property as a vari abl e (w i th the var keyw ord),  because its initial  value may not
be retrieved until  after instance initialization completes.  Constant properties must always have a value before
initialization completes,  and therefore cannot be declared as lazy.
Lazy properties are useful  when the ini tial  value for a property i s dependent on outside
factors whose values are not known unti l  after an instance’s ini tial i zation i s complete.
Lazy properties are al so useful  when the ini tial  value for a property requi res complex or
computational ly expensive setup that should not be performed unless or unti l  i t i s
needed.

게으론 속성은 초기화(initialization)가 끝난 뒤에도 초기값을 꺼낼 수 없을지도 모르기 때문에 언제나 var 키워드를 통해 변수로 선언되어야한다. 반면, 상수 속성은 초기화가 끝나기 전에 반드시 값을 가져야하기 때문에 게으른 속성으로 선언될 수 없다. 
게으른 속성은 속성의 초기값이 객체의 초기화가 끝날때까지도 값을 알 수 없는 외부 변수에 의존하고 있을때 유용하다. 
게으른 속성은 속성의 값이 매우 복잡하거나 리소스를 많이 사용하는 (expensive) 계산이어서 필요한 경우가 아니면 수행되지 말아야 하는 경우에도 역시 유용하다. 

The example below uses a lazy stored property to avoid unnecessary ini tial i zation of a
complex class. Thi s example defines two classes cal led DataImporter and DataManager, nei ther
of whi ch i s shown in ful l :

아래 예시는 복잡한 클래스의 불필요한 초기화를 피하기 위해 게으른 저장속성을 사용하고 있다. 예시된 코드는 DataImporter 클래스와 DataManager 클래스 정의의 일부분이다. 

```swift
class DataImporter {
/*
DataImporter는 외부 화일로부터 데이터를 가져오는 클래스로 
초기화에 오랜 시간이 걸린다고 가정하자.
*/
var fileName = "data. txt"

// 이 곳에 DataImporter 클래스의 데이터 가져오기 기능이 구현된다.
}

DataManager {
@lazy var importer = DataImporter()
ar data = String[]()
// DataManager 클래스의 데이터 관리 기능은 여기에 구현된다.
manager = DataManager()
ager.data += "Some data"
ager.data += "Some more data"
// importer 속성에 할당된 DataImporter 인스턴스는 아직 생성되지 않았다.
```

The DataManager class has a stored property called data, which is initialized with a new, empty array of String values. Although the rest of its functionality is not shown, the purpose of this DataManager class is to manage and provide access to this array of String data.

DataManager 클래스는 data라는 저장속성을 가지는데, 이 data 저장속성은 새로운 String 값들로 이루어진 빈 배열로 초기화된다. 나머지 기능들은 코드에 드러나지 않지만, DataManager 클래스의 목적은 이 String 데이터의 배열을 외부에서 접근하여 사용하도록 관리하는 것이다.

Part of the functionality of the DataManager class is the ability to import data from a file. This functionality is provided by the DataImporter class, which is assumed to take a non-trivial amount of time to initialize. This might be because a DataImporter instance needs to open a file and read its contents into memory when the DataImporter instance is initialized.

DataManager 클래스의 기능 중 하나는 파일에서 데이터를 가져오는 것이다. 이 기능은 초기화하는데 많은 시간이 드는 DataImporter 클래스가 제공한다. 이것은 DataImporter 인스턴스가 초기화될때 화일로부터 데이터를 읽어 메모리로 로드해야하기 때문이라고 가정하자. 

It is possible for a DataManager instance to manage its data without ever importing data from a file, so there is no need to create a new DataImporter instance when the DataManager itself is created. Instead, it makes more sense to create the DataImporter instance if and when it is first used.

DataManager 인스턴스가 데이터를 관리할 때 파일에서 읽어오지 않는 경우도 있을 수 있다. 이런 경우엔 DataManager가 생성될때, DataImporter 인스턴스를  생성하는 것은 불필요하다. 대신에, DataImporter 인스턴스를 최초로 사용할때 생성되도록 하는 것이 더 좋다.

Because it is marked with the @lazy attribute, the DataImporter instance for the importer property is only created when the importer property is first accessed, such as when its fileName property is queried:

게으른 속성(@lazy)으로 표시되어있기 때문에, DataImporter 인스턴스인 DataManager의 importer 속성은 fileName 속성을 조회할 때와 같은 최초의 접근시 생성된다.

```
println(manager.importer.fileName)
// DataImporter 인스턴스인 importer 속성이 여기서 생성된다
// prints "data.txt"
```

# 저장속성과 인스턴스 변수 (Stored Properties and Instance Variables)

If you have experience with Objective-C, you may know that it provides two ways to store values and references as part of a class instance. In addition to properties, you can use instance variables as a backing store for the values stored in a property.

Swift unifies these concepts into a single property declaration. A Swift property does not have a corresponding instance variable, and the backing store for a property is not accessed directly. This approach avoids confusion about how the value is accessed in different contexts and simplifies the property’s declaration into a single, definitive statement. All information about the property—including its name, type, and memory management characteristics—is defined in a single location as part of the type’s definition.

# 계산속성 (Computed Properties)

In addition to stored properties, classes, structures, and enumerations can define computed properties, which do not actually store a value. Instead, they provide a getter and an optional setter to retrieve and set other properties and values indirectly.

```
struct Point {
    var x = 0.0, y = 0.0
}
struct Size {
    var width = 0.0, height = 0.0
}
struct Rect {
    var origin = Point()
    var size = Size()
    var center: Point {
    get {
        let centerX = origin.x + (size.width / 2)
        let centerY = origin.y + (size.height / 2)
        return Point(x: centerX, y: centerY)
    }
    set(newCenter) {
        origin.x = newCenter.x - (size.width / 2)
        origin.y = newCenter.y - (size.height / 2)
    }
    }
}
var square = Rect(origin: Point(x: 0.0, y: 0.0),
    size: Size(width: 10.0, height: 10.0))
let initialSquareCenter = square.center
square.center = Point(x: 15.0, y: 15.0)
println("square.origin is now at (\(square.origin.x), \(square.origin.y))")
// prints "square.origin is now at (10.0, 10.0)"
```
This example defines three structures for working with geometric shapes:

* Point encapsulates an (x, y) coordinate.
* Size encapsulates a width and a height.
* Rect defines a rectangle by an origin point and a size.

The Rect structure al so provides a computed property cal led center. The current center


posi tion of a Rect can always be determined from i ts ori gi n and si ze, and so you don’t need to
store the center point as an expl i ci t Poi nt value. Instead, Rect defines a custom getter and
setter for a computed variable cal led center, to enable you to work wi th the rectangle’s
center as i f i t were a real  stored property.
The preceding example creates a new Rect variable cal led square. The square variable i s
ini tial i zed wi th an origin point of (0,  0), and a width and height of 10. Thi s square i s
represented by the blue square in the diagram below.
The square variable’s center property i s then accessed through dot syntax (square. center), whi ch
causes the getter for center to be cal led, to retrieve the current property value. Rather than
returning an exi sting value, the getter actual ly cal culates and returns a new Poi nt to
represent the center of the square. As can be seen above, the getter correctly returns a
center point of (5,  5).
The center property i s then set to a new value of (15,  15), whi ch moves the square up and to
the right, to the new posi tion shown by the orange square in the diagram below. Setting
the center property cal l s the setter for center, whi ch modi fies the x and y values of the stored
ori gi n property, and moves the square to i ts new posi tion.
Shorthand Setter Declaration
If a computed property’s setter does not define a name for the new value to be set, a
defaul t name of new Val ue i s used. Here’s an al ternative version of the Rect structure, whi ch
takes advantage of thi s shorthand notation:
struct Al ternati veRect {
var ori gi n = Poi nt()
var si ze = Si ze()
var center: Poi nt {
get {
l et centerX = ori gi n. x + (si ze.w i dth / 2)
l et centerY  = ori gi n. y + (si ze. hei ght / 2)
return Poi nt(x: centerX,  y: centerY )
}
et {
ori gi n. x = new Val ue. x -  (si ze.w i dth / 2)
ori gi n. y = new Val ue. y -  (si ze. hei ght / 2)
Read-Only Computed Properties
A computed property wi th a getter but no setter i s known as a read-only computed
property. A read-only computed property always returns a value, and can be accessed
through dot syntax, but cannot be set to a di fferent value.
N O T E
Y ou must decl are computed properti es—i ncl udi ng read-onl y computed properti es—as vari abl e properti es w i th
the var keyw ord,  because thei r val ue i s not fi xed.  T he l et keyw ord i s onl y used for constant properti es,  to
i ndi cate that thei r val ues cannot be changed once they are set as part of i nstance i ni ti al i zati on.
You can simpl i fy the declaration of a read-only computed property by removing the get
keyword and i ts braces:
struct Cuboi d {
var w i dth = 0. 0,  hei ght = 0. 0,  depth = 0. 0
var vol ume: Doubl e {
return w i dth * hei ght * depth
}
}
l et fourByFi veByT w o = Cuboi d(w i dth: 4. 0,  hei ght: 5. 0,  depth: 2. 0)
pri ntl n("the vol ume of fourByFi veByT w o i s \(fourByFi veByT w o. vol ume)")
// pri nts "the vol ume of fourByFi veByT w o i s 40. 0"
Thi s example defines a new structure cal led Cuboi d, whi ch represents a 3D rectangular box
wi th w i dth, hei ght, and depth properties. Thi s structure al so has a read-only computed
property cal led vol ume, whi ch cal culates and returns the current volume of the cuboid. It
doesn’t make sense for vol ume to be settable, because i t would be ambiguous as to whi ch
values of w i dth, hei ght, and depth should be used for a parti cular vol ume value. Nonetheless, i t
i s useful  for a Cuboi d to provide a read-only computed property to enable external  users to
di scover i ts current cal culated volume.
Property Observers
Property observers observe and respond to changes in a property’s value. Property
observers are cal led every time a property’s value i s set, even i f the new value i s the
same as the property’s current value.
You can add property observers to any stored properties you define, apart from lazy
stored properties. You can al so add property observers to any inheri ted property
(whether stored or computed) by overriding the property wi thin a subclass. Property
overriding i s described in Overriding.
N O T E
Y ou don’t need to defi ne property observers for non-overri dden computed properti es,  because you can
observe and respond to changes to thei r val ue from di rectl y w i thi n the computed property’s setter.
You have the option to define ei ther or both of these observers on a property:
w i l l Set i s cal led just before the value i s stored.
di dSet i s cal led immediately after the new value i s stored.
If you implement a w i l l Set observer, i t i s passed the new property value as a constant
parameter. You can speci fy a name for thi s parameter as part of your w i l l Set
implementation. If you choose not to wri te the parameter name and parentheses wi thin
your implementation, the parameter wi l l  sti l l  be made avai lable wi th a defaul t parameter
name of new Val ue.
Simi larly, i f you implement a di dSet observer, i t wi l l  be passed a constant parameter
containing the old property value. You can name the parameter i f you wi sh, or use the
defaul t parameter name of ol dVal ue.
N O T E
w i l l Set and di dSet observers are not cal l ed w hen a property i s fi rst i ni ti al i zed.  T hey are onl y cal l ed w hen the
property’s val ue i s set outsi de of an i ni ti al i zati on context.
Here’s an example of w i l l Set and di dSet in action. The example below defines a new class
cal led StepCounter, whi ch tracks the total  number of steps that a person takes whi le
walking. Thi s class might be used wi th input data from a pedometer or other step counter
to keep track of a person’s exerci se during thei r dai ly routine.
cl ass StepCounter {
var total Steps: Int = 0 {
w i l l Set(new T otal Steps) {
pri ntl n("About to set total Steps to \(new T otal Steps)")
}
di dSet {
i f total Steps > ol dVal ue  {
pri ntl n("Added \(total Steps -  ol dVal ue) steps")
}
tepCounter = StepCounter()
Counter. total Steps = 200
bout to set total Steps to 200
dded 200 steps
Counter. total Steps = 360
bout to set total Steps to 360
dded 160 steps
Counter. total Steps = 896
bout to set total Steps to 896
dded 536 steps
The StepCounter class declares a total Steps property of type Int. Thi s i s a stored property wi th
w i l l Set and di dSet observers.
The w i l l Set and di dSet observers for total Steps are cal led whenever the property i s assigned a
new value. Thi s i s true even i f the new value i s the same as the current value.
Thi s example’s w i l l Set observer uses a custom parameter name of new T otal Steps for the
upcoming new value. In thi s example, i t simply prints out the value that i s about to be
set.
The di dSet observer i s cal led after the value of total Steps i s updated. It compares the new
value of total Steps against the old value. If the total  number of steps has increased, a
message i s printed to indi cate how many new steps have been taken. The di dSet observer
does not provide a custom parameter name for the old value, and the defaul t name of
ol dVal ue i s used instead.
N O T E
If you assi gn a val ue to a property w i thi n i ts ow n di dSet observer,  the new  val ue that you assi gn w i l l  repl ace
the one that w as just set.
Global and Local Variables
The capabi l i ties described above for computing and observing properties are al so
avai lable to global  variables and local  variables. Global  variables are variables that are
defined outside of any function, method, closure, or type context. Local  variables are
variables that are defined wi thin a function, method, or closure context.
The global  and local  variables you have encountered in previous chapters have al l  been
stored variables. Stored variables, l ike stored properties, provide storage for a value of a
certain type and al low that value to be set and retrieved.
However, you can al so define computed variables and define observers for stored
variables, in ei ther a global  or local  scope. Computed variables cal culate rather than store
a value, and are wri tten in the same way as computed properties.
N O T E
Gl obal  constants and vari abl es are al w ays computed l azi l y,  i n a si mi l ar manner to Lazy Stored Properti es.  Unl i ke
l azy stored properti es,  gl obal  constants and vari abl es do not need to be marked w i th the @l azy attri bute.
Local  constants and vari abl es are never computed l azi l y.
Type Properties
Instance properties are properties that belong to an instance of a parti cular type. Every
time you create a new instance of that type, i t has i ts own set of property values,
separate from any other instance.
You can al so define properties that belong to the type i tsel f, not to any one instance of
that type. There wi l l  only ever be one copy of these properties, no matter how many
instances of that type you create. These kinds of properties are cal led type properties.
Type properties are useful  for defining values that are universal  to al l  instances of a
parti cular type, such as a constant property that al l  instances can use (l ike a stati c
constant in C), or a variable property that stores a value that i s global  to al l  instances of
that type (l ike a stati c variable in C).
For value types (that i s, structures and enumerations), you can define stored and
computed type properties. For classes, you can define computed type properties only.
Stored type properties for value types can be variables or constants. Computed type
properties are always declared as variable properties, in the same way as computed
instance properties.
N O T E
Unl i ke stored i nstance properti es,  you must al w ays gi ve stored type properti es a defaul t val ue.  T hi s i s because
the type i tsel f does not have an i ni ti al i zer that can assi gn a val ue to a stored type property at i ni ti al i zati on ti me.
Type Property Syntax
In C and Objective-C, you define stati c constants and variables associated wi th a type as
global  stati c variables. In Swi ft, however, type properties are wri tten as part of the type’s
defini tion, wi thin the type’s outer curly braces, and each type property i s expl i ci tly scoped
to the type i t supports.
You define type properties for value types wi th the stati c keyword, and type properties for
class types wi th the cl ass keyword. The example below shows the syntax for stored and
computed type properties:
struct SomeStructure {
stati c var storedT ypeProperty = "Some val ue. "
stati c var computedT ypeProperty: Int {
// return an Int val ue here
}
}
enum SomeEnumerati on {
stati c var storedT ypeProperty = "Some val ue. "
stati c var computedT ypeProperty: Int {
/ return an Int val ue here
SomeCl ass {
ass var computedT ypeProperty: Int {
/ return an Int val ue here
N O T E
T he computed type property exampl es above are for read-onl y computed type properti es,  but you can al so
defi ne read-w ri te computed type properti es w i th the same syntax as for computed i nstance properti es.
Querying and Setting Type Properties
Type properties are queried and set wi th dot syntax, just l ike instance properties.
However, type properties are queried and set on the type, not on an instance of that
type. For example:
pri ntl n(SomeCl ass. computedT ypeProperty)
// pri nts "42"
pri ntl n(SomeStructure. storedT ypeProperty)
// pri nts "Some val ue. "
SomeStructure. storedT ypeProperty = "Another val ue. "
pri ntl n(SomeStructure. storedT ypeProperty)
// pri nts "Another val ue. "
The examples that fol low use two stored type properties as part of a structure that
model s an audio level  meter for a number of audio channel s. Each channel  has an integer
audio level  between 0 and 10 inclusive.
The figure below i l lustrates how two of these audio channel s can be combined to model  a
stereo audio level  meter. When a channel ’s audio level  i s 0, none of the l ights for that
channel  are l i t. When the audio level  i s 10, al l  of the l ights for that channel  are l i t. In thi s
figure, the left channel  has a current level  of 9, and the right channel  has a current level
of 7:
The audio channel s described above are represented by instances of the Audi oChannel
structure:
struct Audi oChannel  {
stati c l et threshol dLevel  = 10
stati c var maxInputLevel ForAl l Channel s = 0
var currentLevel : Int = 0 {
di dSet {
i f currentLevel  > Audi oChannel . threshol dLevel  {
// cap the new  audi o l evel  to the threshol d l evel
currentLevel  = Audi oChannel . threshol dLevel
}
i f currentLevel  > Audi oChannel .maxInputLevel ForAl l Channel s {
// store thi s as the new  overal l  maxi mum i nput l evel
Audi oChannel .maxInputLevel ForAl l Channel s = currentLevel
}
The Audi oChannel  structure defines two stored type properties to support i ts functional i ty.
The fi rst, threshol dLevel , defines the maximum threshold value an audio level  can take. Thi s
i s a constant value of 10 for al l  Audi oChannel  instances. If an audio signal  comes in wi th a
higher value than 10, i t wi l l  be capped to thi s threshold value (as described below).
The second type property i s a variable stored property cal led maxInputLevel ForAl l Channel s. Thi s
keeps track of the maximum input value that has been received by any Audi oChannel
instance. It starts wi th an ini tial  value of 0.
The Audi oChannel  structure al so defines a stored instance property cal led currentLevel , whi ch
represents the channel ’s current audio level  on a scale of 0 to 10.
The currentLevel  property has a di dSet property observer to check the value of currentLevel
whenever i t i s set. Thi s observer performs two checks:
If the new value of currentLevel  i s greater than the al lowed threshol dLevel , the property
observer caps currentLevel  to threshol dLevel .
If the new value of currentLevel  (after any capping) i s higher than any value
N O T E
In the fi rst of these tw o checks,  the di dSet observer sets currentLevel  to a di fferent val ue.  T hi s does not,
how ever,  cause the observer to be cal l ed agai n.
You can use the Audi oChannel  structure to create two new audio channel s cal led l eftChannel  and
ri ghtChannel , to represent the audio level s of a stereo sound system:
var l eftChannel  = Audi oChannel ()
var ri ghtChannel  = Audi oChannel ()
If you set the currentLevel  of the left channel  to 7, you can see that the maxInputLevel ForAl l Channel s
type property i s updated to equal  7:
l eftChannel . currentLevel  = 7
pri ntl n(l eftChannel . currentLevel )
// pri nts "7"
pri ntl n(Audi oChannel .maxInputLevel ForAl l Channel s)
// pri nts "7"
If you try to set the currentLevel  of the right channel  to 11, you can see that the right
channel ’s currentLevel  property i s capped to the maximum value of 10, and the
maxInputLevel ForAl l Channel s type property i s updated to equal  10:
ri ghtChannel . currentLevel  = 11
pri ntl n(ri ghtChannel . currentLevel )
// pri nts "10"
pri ntl n(Audi oChannel .maxInputLevel ForAl l Channel s)
// pri nts "10"
